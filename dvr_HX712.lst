C51 COMPILER V7.50   DVR_HX712                                                             09/19/2022 12:17:46 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE DVR_HX712
OBJECT MODULE PLACED IN dvr_HX712.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE _weight\dvr_HX712.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\dvr_HX712.lst) 
                    -OBJECT(dvr_HX712.obj)

line level    source

   1          /* Includes ------------------------------------------------------------------*/
   2          #include "./_weight/dvr_HX712.h"
   3          //#include <stdio.h>
   4          //#include <string.h>
   5          #include <REG52.H>
   6          //#include <math.h>
   7          //#include "./customer/keyboard.h"
   8          //#include "./_display/dvr_lcd_SDI1621.h"
   9          
  10          sbit MISO = P0^3;       
  11          sbit SCLK = P0^4;       
  12          
  13          float ValueCount = 0.0;
  14          
  15          //--------------------------------------------------------------------------------
  16          
  17          //int iCountFailRead = 0;
  18          //int iCountFailResponse = 0;
  19          //unsigned char iSelectFrecuency = 1;
  20          float arfDataFilter_x[10] = {0.00};
  21          float arfLowestToHighest[10] = {0.00};
  22          //float fBeforeValue_x = 0;
  23          float fAverage_x = 0;
  24          unsigned char iValueOut = 0;
  25          
  26          /*
  27          */
  28          float fFilter_Averaging(unsigned long iActualWeight, unsigned char cFastFill){  
  29   1              
  30   1              //////////////////////////////////////////float fThreshold = stScaleParam.fFactorCalibrate[stScaleParam.i
             -Units]/2;
  31   1              float fThreshold = 8.526937/2;
  32   1              float fData_Vector = 0;
  33   1              float *pfData_Filter;
  34   1              float fActualWeight = (float)(iActualWeight);
  35   1              unsigned char iLenthData_x = 6;         // Longitud de los datos a ordenar, original 6, en prueba 10 
  36   1              unsigned char i = 0;    // Variable para ciclos iterativo 
  37   1          unsigned char j = 0;        // Variable para ciclos iterativo 
  38   1              
  39   1              pfData_Filter = arfDataFilter_x;
  40   1              
  41   1              if((fActualWeight > fAverage_x + fThreshold || fActualWeight < fAverage_x - fThreshold) && cFastFill == 0
             -){
  42   2                      if(iValueOut++ > 2){
  43   3                              iValueOut = 0;  
  44   3                              for(i=0; i<iLenthData_x-1; i++){
  45   4                                      pfData_Filter[i] = fActualWeight;
  46   4                              }                       
  47   3                      }else{
  48   3                              return fAverage_x;
  49   3                      }
  50   2              }else if(cFastFill == 1){       //Llena todo el vector de promedios con el mismo valor
  51   2                      iValueOut = 0;          
  52   2                      for(i=0; i<iLenthData_x-1; i++){
C51 COMPILER V7.50   DVR_HX712                                                             09/19/2022 12:17:46 PAGE 2   

  53   3                              pfData_Filter[i] = iActualWeight;
  54   3                      }
  55   2              }else if(cFastFill == 2){       //Indica que es el inicio para tomar referencia a Zero.
  56   2                      for(i=0; i<iLenthData_x-1; i++){
  57   3                              pfData_Filter[i] = pfData_Filter[i+1];
  58   3                      }
  59   2              }else{          // Agrega nuevo valor al vector para promedio           
  60   2                      iValueOut = 0;          
  61   2                      for(i=0; i<iLenthData_x-1; i++){
  62   3                              pfData_Filter[i] = pfData_Filter[i+1];
  63   3                      }
  64   2              }
  65   1              
  66   1                              
  67   1              pfData_Filter[iLenthData_x-1] = fActualWeight;
  68   1              
  69   1              for(i=0; i<iLenthData_x; i++){
  70   2                      arfLowestToHighest[i] = pfData_Filter[i];
  71   2              }
  72   1              
  73   1              // Se ordenan los datos de menor a mayor por el metodo burbuja 
  74   1              for (i = 0; i < iLenthData_x -1 ; i++) {        
  75   2                      for (j = (i + 1); j < iLenthData_x ; j++) {                     
  76   3                              if (arfLowestToHighest[j] < arfLowestToHighest[i]) {
  77   4                                      fData_Vector = arfLowestToHighest[j];
  78   4                                      arfLowestToHighest[j] = arfLowestToHighest[i];
  79   4                                      arfLowestToHighest[i] = fData_Vector;
  80   4                              }
  81   3                      }        
  82   2              }
  83   1              
  84   1              fAverage_x = 0;
  85   1              
  86   1              for(i=1; i<iLenthData_x-1; i++){
  87   2                      fAverage_x += arfLowestToHighest[i];
  88   2              }
  89   1              
  90   1              fAverage_x /= (float)(iLenthData_x - 2);
  91   1              
  92   1              //fBeforeValue_x = fAverage_x;
  93   1              
  94   1              return fAverage_x;
  95   1      }
  96          
  97          
  98          /*
  99          */
 100          /*
 101          */
 102          float fRead_Adc(unsigned char cFillFilter){
 103   1              unsigned long iTemp_RA = 0;
 104   1              unsigned char txt[20]={0};
 105   1      
 106   1              if(MISO!=0)return ValueCount;
 107   1          
 108   1        //iTemp_RA=123456789; sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 109   1              
 110   1              iTemp_RA=ReadHX712(); 
 111   1      
 112   1        //sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 113   1      
 114   1              iTemp_RA >>= 7; // Elimina los 6 bits menos significativos
C51 COMPILER V7.50   DVR_HX712                                                             09/19/2022 12:17:46 PAGE 3   

 115   1          
 116   1      
 117   1          // sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 118   1              
 119   1              if(iTemp_RA == 65535){
 120   2              }else if(iTemp_RA > 65535){
 121   2                      iTemp_RA = 131072 - iTemp_RA;
 122   2                      iTemp_RA = 32500 - iTemp_RA;
 123   2              }else{
 124   2                      iTemp_RA += 32500;
 125   2              }
 126   1      
 127   1         // sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 128   1      
 129   1              ValueCount = fFilter_Averaging(iTemp_RA,cFillFilter);
 130   1      
 131   1         // sprintf(txt,"%f      ",ValueCount);  LCD_GLASS_String(txt,LCD_PESO);      delay_ms(500);  
 132   1      
 133   1              return ValueCount;
 134   1      }
 135          
 136          volatile unsigned long  ReadHX712(void){ //by ERH
 137   1          unsigned int i;
 138   1              unsigned long *ptr;     
 139   1          unsigned char  dato[4]={0};
 140   1          ptr=(unsigned long *)&dato;
 141   1      
 142   1              if(MISO!=0)return;
*** WARNING C173 IN LINE 142 OF _WEIGHT\DVR_HX712.C: missing return-expression
 143   1              for(i=0;i<24;i++)//24 bits de comunicación
 144   1              {    
 145   2              SCLK=1;  
 146   2              dato[i/8+1]<<=1;//Lectura en flanco negativo
 147   2                  SCLK=0; 
 148   2              dato[i/8+1]|=MISO&0x01;
 149   2              }
 150   1              //1 bit de configuración a 10Hz
 151   1              SCLK=1;   i<<=5;
 152   1              SCLK=0;  
 153   1        // sprintf(txt,"%lX",*ptr);  LCD_GLASS_String(txt,LCD_TOTAL); 
 154   1         return *ptr;
 155   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1454    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =     89      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
