C51 COMPILER V7.50   DVR_HX712                                                             09/22/2022 19:26:34 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE DVR_HX712
OBJECT MODULE PLACED IN dvr_HX712.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE _weight\dvr_HX712.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\dvr_HX712.lst) 
                    -OBJECT(dvr_HX712.obj)

line level    source

   1          /* Includes ------------------------------------------------------------------*/
   2          #include "./_weight/dvr_HX712.h"
   3          #include <stdio.h>
   4          #include <string.h>
   5          #include <REG52.H>
   6          #include <math.h>
   7          #include "./customer/keyboard.h"
   8          //#include "./_display/dvr_lcd_SDI1621.h"
   9          
  10          sbit MISO = P0^3;       
  11          sbit SCLK = P0^4;       
  12          
  13          
  14          //--------------------------------------------------------------------------------
  15          float ValueCount = 0.0;
  16          int iCountFailRead = 0;
  17          int iCountFailResponse = 0;
  18          
  19          unsigned char iSelectFrecuency = 1;
  20          float arfDataFilter_x[10] = {0};
  21          float fBeforeValue_x = 0;
  22          float fAverage_x = 0;
  23          unsigned char iValueOut = 0;
  24          
  25          /*
  26          */
  27          float fFilter_Averaging(unsigned long iActualWeight, unsigned char cFastFill){  
  28   1              float arfLowestToHighest[10] = {0.00};
  29   1              //////////////////////////////////////////float fThreshold = stScaleParam.fFactorCalibrate[stScaleParam.i
             -Units]/2;
  30   1              float fThreshold = 8.526937/2;
  31   1              float fData_Vector = 0;
  32   1              float *pfData_Filter;
  33   1              float fActualWeight = (float)(iActualWeight);
  34   1              unsigned char iLenthData_x = 6;         // Longitud de los datos a ordenar, original 6, en prueba 10 
  35   1              unsigned char i = 0;    // Variable para ciclos iterativo 
  36   1          unsigned char j = 0;        // Variable para ciclos iterativo 
  37   1              
  38   1              pfData_Filter = arfDataFilter_x;
  39   1              
  40   1              if((fActualWeight > fAverage_x + fThreshold || fActualWeight < fAverage_x - fThreshold) && cFastFill == 0
             -){
  41   2                      if(iValueOut++ > 2){
  42   3                              iValueOut = 0;  
  43   3                              for(i=0; i<iLenthData_x-1; i++){
  44   4                                      pfData_Filter[i] = fActualWeight;
  45   4                              }                       
  46   3                      }else{
  47   3                              return fAverage_x;
  48   3                      }
  49   2              }else if(cFastFill == 1){       //Llena todo el vector de promedios con el mismo valor
  50   2                      iValueOut = 0;          
  51   2                      for(i=0; i<iLenthData_x-1; i++){
  52   3                              pfData_Filter[i] = iActualWeight;
C51 COMPILER V7.50   DVR_HX712                                                             09/22/2022 19:26:34 PAGE 2   

  53   3                      }
  54   2              }else if(cFastFill == 2){       //Indica que es el inicio para tomar referencia a Zero.
  55   2                      for(i=0; i<iLenthData_x-1; i++){
  56   3                              pfData_Filter[i] = pfData_Filter[i+1];
  57   3                      }
  58   2              }else{          // Agrega nuevo valor al vector para promedio           
  59   2                      iValueOut = 0;          
  60   2                      for(i=0; i<iLenthData_x-1; i++){
  61   3                              pfData_Filter[i] = pfData_Filter[i+1];
  62   3                      }
  63   2              }
  64   1              
  65   1                              
  66   1              pfData_Filter[iLenthData_x-1] = fActualWeight;
  67   1              
  68   1              for(i=0; i<iLenthData_x; i++){
  69   2                      arfLowestToHighest[i] = pfData_Filter[i];
  70   2              }
  71   1              
  72   1              // Se ordenan los datos de menor a mayor por el metodo burbuja 
  73   1              for (i = 0; i < iLenthData_x -1 ; i++) {        
  74   2                      for (j = (i + 1); j < iLenthData_x ; j++) {                     
  75   3                              if (arfLowestToHighest[j] < arfLowestToHighest[i]) {
  76   4                                      fData_Vector = arfLowestToHighest[j];
  77   4                                      arfLowestToHighest[j] = arfLowestToHighest[i];
  78   4                                      arfLowestToHighest[i] = fData_Vector;
  79   4                              }
  80   3                      }        
  81   2              }
  82   1              
  83   1              fAverage_x = 0;
  84   1              
  85   1              for(i=1; i<iLenthData_x-1; i++){
  86   2                      fAverage_x += arfLowestToHighest[i];
  87   2              }
  88   1              
  89   1              fAverage_x /= (float)(iLenthData_x - 2);
  90   1              
  91   1              fBeforeValue_x = fAverage_x;
  92   1              
  93   1              return fAverage_x;
  94   1      }
  95          
  96          
  97          /*
  98          */
  99          /*
 100          */
 101          float fRead_Adc(unsigned char cFillFilter){
 102   1              unsigned long iTemp_RA = 0;
 103   1      
 104   1              while(MISO!=0 && iTemp_RA<250){
 105   2            delay_ms(1);        iTemp_RA++;
 106   2          }
 107   1              if(MISO!=0)return ValueCount;
 108   1        //iTemp_RA=123456789; sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 109   1              
 110   1              iTemp_RA=ReadHX712(); 
 111   1      
 112   1        //sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 113   1      
 114   1              iTemp_RA >>= 7; // Elimina los 6 bits menos significativos
C51 COMPILER V7.50   DVR_HX712                                                             09/22/2022 19:26:34 PAGE 3   

 115   1          
 116   1      
 117   1          // sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 118   1              
 119   1              if(iTemp_RA == 65535){
 120   2              }else if(iTemp_RA > 65535){
 121   2                      iTemp_RA = 131072 - iTemp_RA;
 122   2                      iTemp_RA = 32500 - iTemp_RA;
 123   2              }else{
 124   2                      iTemp_RA += 32500;
 125   2              }
 126   1      
 127   1         // sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 128   1      
 129   1              ValueCount = fFilter_Averaging(iTemp_RA,cFillFilter);
 130   1      
 131   1         // sprintf(txt,"%f      ",ValueCount);  LCD_GLASS_String(txt,LCD_PESO);      delay_ms(500);  
 132   1      
 133   1              return ValueCount;
 134   1      }
 135          
 136          volatile unsigned long  ReadHX712(void){ //by ERH
 137   1          unsigned int i;
 138   1              unsigned long *ptr;     
 139   1          unsigned char  dato[4]={0};
 140   1          ptr=(unsigned long *)&dato;
 141   1      
 142   1              if(MISO!=0)return;
*** WARNING C173 IN LINE 142 OF _WEIGHT\DVR_HX712.C: missing return-expression
 143   1              for(i=0;i<24;i++)//24 bits de comunicación
 144   1              {    
 145   2              SCLK=1;  
 146   2              dato[i/8+1]<<=1;//Lectura en flanco negativo
 147   2                  SCLK=0; 
 148   2              dato[i/8+1]|=MISO&0x01;
 149   2              }
 150   1              //1 bit de configuración a 10Hz
 151   1              SCLK=1;   i<<=5;
 152   1              SCLK=0;  
 153   1        // sprintf(txt,"%lX",*ptr);  LCD_GLASS_String(txt,LCD_TOTAL); 
 154   1         return *ptr;
 155   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1543    ----
   CONSTANT SIZE    =     44    ----
   XDATA SIZE       =     58      75
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
