C51 COMPILER V7.50   DVR_HX712                                                             09/22/2022 15:01:15 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE DVR_HX712
OBJECT MODULE PLACED IN dvr_HX712.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE _weight\dvr_HX712.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\dvr_HX712.lst) 
                    -OBJECT(dvr_HX712.obj)

line level    source

   1          /* Includes ------------------------------------------------------------------*/
   2          #include "./_weight/dvr_HX712.h"
   3          //#include <stdio.h>
   4          //#include <string.h>
   5          #include <REG52.H>
   6          //#include <math.h>
   7          //#include "./customer/keyboard.h"
   8          //#include "./_display/dvr_lcd_SDI1621.h"
   9          
  10          sbit MISO = P0^3;       
  11          sbit SCLK = P0^4;       
  12          
  13          float ValueCount = 0.0;
  14          
  15          //--------------------------------------------------------------------------------
  16          
  17          //int iCountFailRead = 0;
  18          //int iCountFailResponse = 0;
  19          //unsigned char iSelectFrecuency = 1;
  20          
  21          
  22          /*
  23          */
  24          float fFilter_Averaging(unsigned long iActualWeight, unsigned char cFastFill){  
  25   1      
  26   1      float fAverage_x = 0;
  27   1      float xdata arfDataFilter_x[5] = {0.00};
  28   1      float xdata arfLowestToHighest[5] = {0.00};
  29   1      unsigned char xdata iValueOut = 0;      
  30   1      //    float xdata fThreshold = stScaleParam.fFactorCalibrate[stScaleParam.iUnits]/2;
  31   1              float fThreshold = 8.526937/2;
  32   1              float xdata fData_Vector = 0;
  33   1              float xdata *pfData_Filter;
  34   1              float xdata fActualWeight = (float)(iActualWeight);
  35   1              unsigned char xdata iLenthData_x = 5;           // Longitud de los datos a ordenar, original 6, en prueba 10 
  36   1              unsigned char xdata i = 0;      // Variable para ciclos iterativo 
  37   1          unsigned char xdata j = 0;  // Variable para ciclos iterativo 
  38   1              
  39   1              pfData_Filter = arfDataFilter_x;
  40   1              
  41   1              if((fActualWeight > fAverage_x + fThreshold || fActualWeight < fAverage_x - fThreshold) && cFastFill == 0
             -){
  42   2                      if(iValueOut++ > 2){
  43   3                              iValueOut = 0;  
  44   3                              for(i=0; i<iLenthData_x-1; i++){
  45   4                                      pfData_Filter[i] = fActualWeight;
  46   4                              }                       
  47   3                      }else{
  48   3                              return fAverage_x;
  49   3                      }
  50   2              }else if(cFastFill == 1){       //Llena todo el vector de promedios con el mismo valor
  51   2                      iValueOut = 0;          
  52   2                      for(i=0; i<iLenthData_x-1; i++){
  53   3                              pfData_Filter[i] = iActualWeight;
C51 COMPILER V7.50   DVR_HX712                                                             09/22/2022 15:01:15 PAGE 2   

  54   3                      }
  55   2              }else if(cFastFill == 2){       //Indica que es el inicio para tomar referencia a Zero.
  56   2                      for(i=0; i<iLenthData_x-1; i++){
  57   3                              pfData_Filter[i] = pfData_Filter[i+1];
  58   3                      }
  59   2              }else{          // Agrega nuevo valor al vector para promedio           
  60   2                      iValueOut = 0;          
  61   2                      for(i=0; i<iLenthData_x-1; i++){
  62   3                              pfData_Filter[i] = pfData_Filter[i+1];
  63   3                      }
  64   2              }
  65   1              
  66   1                              
  67   1              pfData_Filter[iLenthData_x-1] = fActualWeight;
  68   1              
  69   1              for(i=0; i<iLenthData_x; i++){
  70   2                      arfLowestToHighest[i] = pfData_Filter[i];
  71   2              }
  72   1              
  73   1              // Se ordenan los datos de menor a mayor por el metodo burbuja 
  74   1              for (i = 0; i < iLenthData_x -1 ; i++) {        
  75   2                      for (j = (i + 1); j < iLenthData_x ; j++) {                     
  76   3                              if (arfLowestToHighest[j] < arfLowestToHighest[i]) {
  77   4                                      fData_Vector = arfLowestToHighest[j];
  78   4                                      arfLowestToHighest[j] = arfLowestToHighest[i];
  79   4                                      arfLowestToHighest[i] = fData_Vector;
  80   4                              }
  81   3                      }        
  82   2              }
  83   1              
  84   1              fAverage_x = 0;
  85   1              
  86   1              for(i=1; i<iLenthData_x-1; i++){
  87   2                      fAverage_x += arfLowestToHighest[i];
  88   2              }
  89   1              
  90   1              fAverage_x /= (float)(iLenthData_x - 2);
  91   1              
  92   1              //fBeforeValue_x = fAverage_x;
  93   1      
  94   1      
  95   1              
  96   1              return fAverage_x;
  97   1      }
  98          
  99          
 100          /*
 101          */
 102          /*
 103          */
 104          float fRead_Adc(unsigned char cFillFilter){
 105   1              unsigned long iTemp_RA = 0;
 106   1      
 107   1              if(MISO!=0)return ValueCount;
 108   1          
 109   1        //iTemp_RA=123456789; sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 110   1              
 111   1              ReadHX712(&iTemp_RA); 
 112   1      
 113   1        //sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 114   1       iTemp_RA >>= 7;        // Elimina los 6 bits menos significativos
 115   1              
C51 COMPILER V7.50   DVR_HX712                                                             09/22/2022 15:01:15 PAGE 3   

 116   1          
 117   1      
 118   1          // sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 119   1              
 120   1              if(iTemp_RA == 65535){
 121   2              }else if(iTemp_RA > 65535){
 122   2                      iTemp_RA = 131072 - iTemp_RA;
 123   2                      iTemp_RA = 32500 - iTemp_RA;
 124   2              }else{
 125   2                      iTemp_RA += 32500;
 126   2              }
 127   1      
 128   1         // sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 129   1      
 130   1              ValueCount = fFilter_Averaging(iTemp_RA,cFillFilter);
 131   1      
 132   1         // sprintf(txt,"%f      ",ValueCount);  LCD_GLASS_String(txt,LCD_PESO);      delay_ms(500);  
 133   1      
 134   1              return ValueCount;
 135   1      }
 136          
 137          void ReadHX712(unsigned char *ptr       ){ //by ERH
*** WARNING C235 IN LINE 137 OF _WEIGHT\DVR_HX712.C: parameter 1: different types
 138   1          unsigned char i;
 139   1          unsigned char  dato[4]={0};
 140   1          ptr=(unsigned long *)&dato;
*** WARNING C182 IN LINE 140 OF _WEIGHT\DVR_HX712.C: pointer to different objects
 141   1      
 142   1              if(MISO!=0)return;
 143   1              for(i=0;i<24;i++)//24 bits de comunicación
 144   1              {    
 145   2              SCLK=1;  
 146   2              dato[i/8+1]<<=1;//Lectura en flanco negativo
 147   2                  SCLK=0; 
 148   2              dato[i/8+1]|=MISO&0x01;
 149   2              }
 150   1              //1 bit de configuración a 10Hz
 151   1              SCLK=1;   i<<=5;
 152   1              SCLK=0;  
 153   1              
 154   1        // sprintf(txt,"%lX",*ptr);  LCD_GLASS_String(txt,LCD_TOTAL); 
 155   1      
 156   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1427    ----
   CONSTANT SIZE    =     44    ----
   XDATA SIZE       =      4      76
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
