C51 COMPILER V7.50   DVR_HX712                                                             09/27/2022 15:48:27 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE DVR_HX712
OBJECT MODULE PLACED IN dvr_HX712.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE _weight\dvr_HX712.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\dvr_HX712.lst) 
                    -OBJECT(dvr_HX712.obj)

line level    source

   1          /* Includes ------------------------------------------------------------------*/
   2          #include "./_weight/dvr_HX712.h"
   3          #include <stdio.h>
   4          #include <string.h>
   5          #include <REG52.H>
   6          #include <math.h>
   7          #include "./customer/keyboard.h"
   8          //#include "./_display/dvr_lcd_SDI1621.h"
   9          
  10          sbit MISO = P0^3;       
  11          sbit SCLK = P0^4;       
  12          
  13          //--------------------------------------------------------------------------------
  14          float ValueCount = 0.0;
  15          int iCountFailRead = 0;
  16          int iCountFailResponse = 0;
  17          float arfDataFilter_x[5] = {0.00};
  18          float fBeforeValue_x = 0;
  19          float fAverage_x = 0;
  20          unsigned char iValueOut = 0;
  21          
  22          /*
  23          */
  24          float fFilter_Averaging(unsigned long iActualWeight, unsigned char cFastFill){  
  25   1              float arfLowestToHighest[5] = {0.00};
  26   1          float fThreshold = stScaleParam.fFactorCalibrate*0.5;
  27   1              //float fThreshold = 3.327/2;//8.526937/2;
  28   1              float fData_Vector = 0;
  29   1              float *pfData_Filter;
  30   1              float fActualWeight = (float)(iActualWeight);
  31   1              unsigned char iLenthData_x = 5;         // Longitud de los datos a ordenar, original 6, en prueba 10 
  32   1              unsigned char i = 0;    // Variable para ciclos iterativo 
  33   1          unsigned char j = 0;        // Variable para ciclos iterativo 
  34   1              
  35   1              pfData_Filter = arfDataFilter_x;
  36   1              
  37   1              if((fActualWeight > fAverage_x + fThreshold || fActualWeight < fAverage_x - fThreshold) && cFastFill == 0
             -){
  38   2                      if(iValueOut++ > 2){
  39   3                              iValueOut = 0;  
  40   3                              for(i=0; i<iLenthData_x-1; i++){
  41   4                                      pfData_Filter[i] = fActualWeight;
  42   4                              }                       
  43   3                      }else{
  44   3                              return fAverage_x;
  45   3                      }
  46   2              }else if(cFastFill == 1){       //Llena todo el vector de promedios con el mismo valor
  47   2                      iValueOut = 0;          
  48   2                      for(i=0; i<iLenthData_x-1; i++){
  49   3                              pfData_Filter[i] = iActualWeight;
  50   3                      }
  51   2              }else if(cFastFill == 2){       //Indica que es el inicio para tomar referencia a Zero.
  52   2                      for(i=0; i<iLenthData_x-1; i++){
  53   3                              pfData_Filter[i] = pfData_Filter[i+1];
C51 COMPILER V7.50   DVR_HX712                                                             09/27/2022 15:48:27 PAGE 2   

  54   3                      }
  55   2              }else{          // Agrega nuevo valor al vector para promedio           
  56   2                      iValueOut = 0;          
  57   2                      for(i=0; i<iLenthData_x-1; i++){
  58   3                              pfData_Filter[i] = pfData_Filter[i+1];
  59   3                      }
  60   2              }
  61   1              
  62   1                              
  63   1              pfData_Filter[iLenthData_x-1] = fActualWeight;
  64   1              
  65   1              for(i=0; i<iLenthData_x; i++){
  66   2                      arfLowestToHighest[i] = pfData_Filter[i];
  67   2              }
  68   1              
  69   1              // Se ordenan los datos de menor a mayor por el metodo burbuja 
  70   1              for (i = 0; i < iLenthData_x -1 ; i++) {        
  71   2                      for (j = (i + 1); j < iLenthData_x ; j++) {                     
  72   3                              if (arfLowestToHighest[j] < arfLowestToHighest[i]) {
  73   4                                      fData_Vector = arfLowestToHighest[j];
  74   4                                      arfLowestToHighest[j] = arfLowestToHighest[i];
  75   4                                      arfLowestToHighest[i] = fData_Vector;
  76   4                              }
  77   3                      }        
  78   2              }
  79   1              
  80   1              fAverage_x = 0;
  81   1              
  82   1              for(i=1; i<iLenthData_x-1; i++){
  83   2                      fAverage_x += arfLowestToHighest[i];
  84   2              }
  85   1              
  86   1              fAverage_x /= (float)(iLenthData_x - 2);
  87   1              
  88   1              fBeforeValue_x = fAverage_x;
  89   1              
  90   1              return fAverage_x;
  91   1      }
  92          
  93          
  94          /*
  95          */
  96          /*
  97          */
  98          float fRead_Adc(unsigned char cFillFilter){
  99   1              unsigned long iTemp_RA = 0;
 100   1      
 101   1              while(MISO!=0 && iTemp_RA<250){
 102   2            delay_ms(1);        iTemp_RA++;
 103   2          }
 104   1              if(MISO!=0)return ValueCount;
 105   1        //iTemp_RA=123456789; sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 106   1              
 107   1              iTemp_RA=ReadHX712(); 
 108   1      
 109   1        //sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 110   1      
 111   1              iTemp_RA >>= 7; // Elimina los 6 bits menos significativos
 112   1          
 113   1      
 114   1          // sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 115   1              
C51 COMPILER V7.50   DVR_HX712                                                             09/27/2022 15:48:27 PAGE 3   

 116   1              if(iTemp_RA == 65535){
 117   2              }else if(iTemp_RA > 65535){
 118   2                      iTemp_RA = 131072 - iTemp_RA;
 119   2                      iTemp_RA = 32500 - iTemp_RA;
 120   2              }else{
 121   2                      iTemp_RA += 32500;
 122   2              }
 123   1      
 124   1         // sprintf(txt,"%ld   ",iTemp_RA);  LCD_GLASS_String(txt,LCD_PESO); delay_ms(5000);
 125   1      
 126   1              ValueCount = fFilter_Averaging(iTemp_RA,cFillFilter);
 127   1      
 128   1         // sprintf(txt,"%f      ",ValueCount);  LCD_GLASS_String(txt,LCD_PESO);      delay_ms(500);  
 129   1      
 130   1              return ValueCount;
 131   1      }
 132          
 133          volatile unsigned long  ReadHX712(void){ //by ERH
 134   1          unsigned int i;
 135   1              unsigned long *ptr;     
 136   1          unsigned char  dato[4]={0};
 137   1          ptr=(unsigned long *)&dato;
 138   1      
 139   1              if(MISO!=0)return;
*** WARNING C173 IN LINE 139 OF _WEIGHT\DVR_HX712.C: missing return-expression
 140   1              for(i=0;i<24;i++)//24 bits de comunicación
 141   1              {    
 142   2              SCLK=1;  
 143   2              dato[i/8+1]<<=1;//Lectura en flanco negativo
 144   2                  SCLK=0; 
 145   2              dato[i/8+1]|=MISO&0x01;
 146   2              }
 147   1              //1 bit de configuración a 10Hz
 148   1              SCLK=1;   i<<=5;
 149   1              SCLK=0;  
 150   1        // sprintf(txt,"%lX",*ptr);  LCD_GLASS_String(txt,LCD_TOTAL); 
 151   1         return *ptr;
 152   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1562    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =     37      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
