C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE DVR_SCALE
OBJECT MODULE PLACED IN dvr_scale.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE _scale\dvr_scale.c BROWSE DEBUG OBJECTEXTEND PRINT(.\dvr_scale.lst) OBJECT(
                    -dvr_scale.obj)

line level    source

   1          /* Includes ------------------------------------------------------------------*/
   2          #include <stdio.h>
   3          #include <math.h>
   4          #include <string.h>
   5          //#include "stm8l15x.h"
   6          //#include "stm8l15x_iwdg.h"
   7          //#include "main.h"
   8          //#include "dvr_lcd.h"
   9          //#include "dvr_def.h"
  10          //#include "dvr_e2prom.h"       
  11          //#include "dvr_HX712.h"
  12          //#include "dvr_keyboard.h"
  13          //#include "dvr_battery.h"
  14          //#include "dvr_inicio.h"
  15          
  16          #include "./_data_nvm/data_nvm_5219_Vc_Dec09_13.h"      
  17          #include "./_scale/dvr_def.h"
  18          #include "./_display/dvr_lcd_SDI1621.h"
  19          #include "./customer/keyboard.h"
  20          #include "./_weight/dvr_HX712.h"
  21          #include "./_scale/dvr_scale.h"
  22          #include "./_battery/dvr_battery.h"
  23          
  24          /*
  25          #define ADDRESS_SCALE_CONFIG_PAGE    ADDRESS_PAGE_27
  26          #define ADDRESS_QLTY_AND_CNTRS_PAGE  ADDRESS_PAGE_28
  27          #define ADDRESS_PLU                  ADDRESS_PAGE_29
  28          */
  29          
  30          /* --- Direcciones en la EEPROM de los valores */
  31          #define ADDR_SET_CALIBRATE                      ADDRESS_SCALE_CONFIG_PAGE + 0   /* 1 byte */
  32          #define ADDR_CAPACITY_CALI                      ADDRESS_SCALE_CONFIG_PAGE + 1   /* 4 byte */
  33          #define ADDR_POINT_ZERO                         ADDRESS_SCALE_CONFIG_PAGE + 5   /* 4 byte */
  34          #define ADDR_FACTOR_CALIBRATE       ADDRESS_SCALE_CONFIG_PAGE + 9       /* 4 byte */
  35          #define ADDR_LENGUAGE                           ADDRESS_SCALE_CONFIG_PAGE + 13  /* 1 byte */
  36          #define ADDR_UNITS                                      ADDRESS_SCALE_CONFIG_PAGE + 14  /* 1 byte */
  37          #define ADDR_CAPACITY                           ADDRESS_SCALE_CONFIG_PAGE + 15  /* 2 byte */
  38          #define ADDR_PORC_REF                           ADDRESS_SCALE_CONFIG_PAGE + 17  /* 2 byte */
  39          #define ADDR_DIVISION_MINIMA            ADDRESS_SCALE_CONFIG_PAGE + 19  /* 2 byte */
  40          #define ADDR_DECIMAL_TOTAL                      ADDRESS_SCALE_CONFIG_PAGE + 21  /* 1 byte */
  41          #define ADDR_REDONDEO_TOTAL             ADDRESS_SCALE_CONFIG_PAGE + 22  /* 1 byte */
  42          #define ADDR_REDONDEO_VENTA             ADDRESS_SCALE_CONFIG_PAGE + 23  /* 1 byte */
  43          #define ADDR_DECIMAL_PRECIO             ADDRESS_SCALE_CONFIG_PAGE + 24  /* 1 byte */
  44          #define ADDR_ZERO_TRACKING                      ADDRESS_SCALE_CONFIG_PAGE + 25  /* 1 byte */
  45          //#define ADDR_FORMATO_IMPRESION            ADDRESS_SCALE_CONFIG_PAGE + 26      /* 1 byte */
  46          #define ADDR_MSG_UNLOAD                     ADDRESS_SCALE_CONFIG_PAGE + 27      /* 1 byte */
  47          #define ADDR_TIME_OFF                           ADDRESS_SCALE_CONFIG_PAGE + 28  /* 1 byte */
  48          #define ADDR_MODELO                                     ADDRESS_SCALE_CONFIG_PAGE + 29 /* 1 byte */
  49          #define ADDR_BACKLIGHT                          ADDRESS_SCALE_CONFIG_PAGE + 30 /* 1 byte */
  50          #define ADDR_MSGBAT                                     ADDRESS_SCALE_CONFIG_PAGE + 31 /* 1 byte */
  51          //#define ADDR_DEBUG                            ADDRESS_SCALE_CONFIG_PAGE + 43 /* 2 byte */
  52          #define ADDR_COUNT_RANGE                        ADDRESS_SCALE_CONFIG_PAGE + 32 /* 2 byte */
  53          #define ADDR_MONEDA                                     ADDRESS_SCALE_CONFIG_PAGE + 34 /* 1 byte */
  54          #define ADDR_DECIMAL_WEIGHT                     ADDRESS_SCALE_CONFIG_PAGE + 35  /* 2 bytes */
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 2   

  55          #define ADDR_TEMPERATURE                        ADDRESS_SCALE_CONFIG_PAGE + 37  /* 4 Bytes */
  56          #define ADDR_VOLT_BATT                          ADDRESS_SCALE_CONFIG_PAGE + 41  /* 4 Bytes */
  57          #define ADDR_VOLT_ADAP                          ADDRESS_SCALE_CONFIG_PAGE + 45  /* 4 Bytes */
  58          #define ADDR_SAVEBATT                           ADDRESS_SCALE_CONFIG_PAGE + 49  /* 1 byte */
  59          #define ADDR_DIVISION_MENOR                     ADDRESS_SCALE_CONFIG_PAGE + 50  /* 2 bytes */
  60          #define ADDR_MULTIRANGO                         ADDRESS_SCALE_CONFIG_PAGE + 52  /* 1 byte */
  61          #define ADDR_DIVISION_MENORMENOR    ADDRESS_SCALE_CONFIG_PAGE + 53      /* 2 bytes */
  62          
  63          #define ADDR_COUNTER_CALIBRATION    ADDRESS_QLTY_AND_CNTRS_PAGE + 0     /* 2 byte */
  64          #define ADDR_COUNTER_CONFIGURATION  ADDRESS_QLTY_AND_CNTRS_PAGE + 2     /* 2 byte */
  65          #define ADDR_COUNT_OVERLOAD                 ADDRESS_QLTY_AND_CNTRS_PAGE + 4  /* 2 bytes */
  66          #define ADDR_VALUE_OVERLOAD                 ADDRESS_QLTY_AND_CNTRS_PAGE + 6  /* 4 bytes */
  67          #define ADDR_ERRORBATT                      ADDRESS_QLTY_AND_CNTRS_PAGE + 10  /* 1 byte */
  68          #define ADDR_VENTA_TOTAL                    ADDRESS_QLTY_AND_CNTRS_PAGE + 11   /* 4 bytes */
  69          
  70          float xdata fWeightScale = 0;                                                                   /* Contiene el valor del peso leido */
  71          float xdata fWeightScaleBefore = 0;
  72          float xdata fWeightLight = 0;
  73           Parameter xdata stScaleParam;  /* Contiene los parametros de uso de la Bascula*/
  74           FlagScale xdata srFlagScale;           /* Contiene las banderas del sistema */
  75          
  76          int xdata iCounterZeroTracking = 0;
  77          
  78          extern int xdata iCountFailRead;
  79          extern int xdata iCountFailResponse;
  80          
  81          /* --- Prototype Function ----------------------------------------------------*/
  82          void vSaveParamScale(unsigned char cType_Parameter);
  83          void vCalibrate_Scale(void);
  84          void vWeight_Positive(void);
  85          void vWeight_Negative(void);
  86          unsigned char cProduct_Varios(void);
  87          //void vSend_Data_Serial(void);
  88          float fCuentasToPeso(float fCountADC);
  89          void vPrintZero(void);
  90          void vSend_Value(float fValue1, unsigned char uActive1, float fValue2, unsigned char uActive2, float fValu
             -e3, unsigned char uActive3);
  91          float fSleep_Run(void);
  92          
  93          /**
  94            ******************************************************************************
  95            * Objetivo: Asignar valores de parametros de la bascula.
  96            * Parametros entrada: Ninguno.
  97                  * Parametros Salida: Ninguno.
  98            * Prerequisitos: Modifica las variables globales de la estruct stScaleParam
  99            ******************************************************************************
 100            */
 101          void vReadParamScale(void){
 102   1              stScaleParam.fCapacityCali              = flash_read_float32(ADDR_CAPACITY_CALI);
 103   1              stScaleParam.fPointZeroCali             = flash_read_float32(ADDR_POINT_ZERO);
 104   1              stScaleParam.fFactorCalibrate = flash_read_float32(ADDR_FACTOR_CALIBRATE);
 105   1              stScaleParam.fValueTara                         = 0;
 106   1              
 107   1              stScaleParam.cMultirango        = flash_read_u8(ADDR_MULTIRANGO);
 108   1              stScaleParam.cLenguage                          = flash_read_u8(ADDR_LENGUAGE);
 109   1              stScaleParam.cUnits                                     = flash_read_u8(ADDR_UNITS);
 110   1      //      stScaleParam.cFormatoImpresion                          = flash_read_u8(ADDR_FORMATO_IMPRESION);
 111   1              stScaleParam.iCapacity                          =       flash_read_u16(ADDR_CAPACITY);
 112   1              stScaleParam.iLoadPorcRefer     = flash_read_u16(ADDR_PORC_REF);
 113   1              stScaleParam.iDivisionMinima    = flash_read_u16(ADDR_DIVISION_MINIMA);
 114   1              stScaleParam.iDivisionMenor     = flash_read_u16(ADDR_DIVISION_MENOR);
 115   1              stScaleParam.iDivisionMenorMenor        = flash_read_u16(ADDR_DIVISION_MENORMENOR);
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 3   

 116   1              stScaleParam.cPuntoDecimalTotal         = flash_read_u8(ADDR_DECIMAL_TOTAL);
 117   1              stScaleParam.cRedondeoCifraTotal        = flash_read_u8(ADDR_REDONDEO_TOTAL);
 118   1              stScaleParam.cBacklight         = flash_read_u8(ADDR_BACKLIGHT);
 119   1              
 120   1              if(stScaleParam.cRedondeoCifraTotal == 0){
 121   2                      stScaleParam.cValorRedondeoCifraTotal = 5;
 122   2              }else{
 123   2                      stScaleParam.cValorRedondeoCifraTotal = 1;
 124   2              }
 125   1              
 126   1              stScaleParam.cRedondeoCifraVentaTotal   = flash_read_u8(ADDR_REDONDEO_VENTA);
 127   1              
 128   1              if(stScaleParam.cRedondeoCifraVentaTotal == 0){
 129   2                      stScaleParam.cValorcRedondeoCifraVentaTotal = 5;
 130   2              }else{
 131   2                      stScaleParam.cValorcRedondeoCifraVentaTotal = 1;
 132   2              }
 133   1              
 134   1              stScaleParam.cPuntoDecimalPrecio                        = flash_read_u8(ADDR_DECIMAL_PRECIO);
 135   1              stScaleParam.cZeroTracking                                              = 0; //flash_read_u8(ADDR_ZERO_TRACKING);
 136   1              stScaleParam.cMsgUnload                                                         = flash_read_u8(ADDR_MSG_UNLOAD);
 137   1              stScaleParam.cTimeAutooff                                                       = flash_read_u8(ADDR_TIME_OFF);
 138   1              stScaleParam.cModeloBascula                                             = flash_read_u8(ADDR_MODELO);
 139   1                              
 140   1              stScaleParam.iCounter_Calibration       = flash_read_u16(ADDR_COUNTER_CALIBRATION);
 141   1              stScaleParam.iCounter_Configuration     = flash_read_u16(ADDR_COUNTER_CONFIGURATION);
 142   1              
 143   1              stScaleParam.cShowHighBat                                                       = flash_read_u8(ADDR_MSGBAT); 
 144   1              
 145   1      //      stScaleParam.iDebug                                                                     = flash_read_u16(ADDR_DEBUG);
 146   1      
 147   1              stScaleParam.cCountRange                                                        = flash_read_u8(ADDR_COUNT_RANGE);
 148   1              
 149   1              stScaleParam.cMoneda                                                                    = flash_read_u8(ADDR_MONEDA);
 150   1                      
 151   1              stScaleParam.iCountOverload                                             =       flash_read_u16(ADDR_COUNT_OVERLOAD);
 152   1              
 153   1              stScaleParam.fValueOverload                                             =       flash_read_float32(ADDR_VALUE_OVERLOAD);
 154   1              
 155   1              stScaleParam.cWeightDecimal                                     = flash_read_u8(ADDR_DECIMAL_WEIGHT);
 156   1              
 157   1              stScaleParam.cSaveBattery                                       = flash_read_u8(ADDR_SAVEBATT);
 158   1              
 159   1              srFlagScale.bShowErroBat                                                = flash_read_u8(ADDR_ERRORBATT);
 160   1              
 161   1              stScaleParam.fVenta_Total_Scale    = flash_read_float32(ADDR_VENTA_TOTAL);
 162   1      }
 163          
 164          /**
 165            ******************************************************************************
 166            * Objetivo: Guardar parametros en la E2PROM
 167            * Parametros entrada: Ninguno
 168                  * Parametros Salida: Ninguno
 169            ******************************************************************************
 170            */
 171          void vSaveParamScale(unsigned char cType_Parameter){
 172   1      
 173   1              /* Habilita la escritura/lectura en la EEPROM */
 174   1              NRM_securty_a = 0xaa;
 175   1              NRM_securty_b = 0x55;
 176   1      
 177   1              /*e2rom_erase(ADDRESS_PAGE_26);
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 4   

 178   1              e2rom_erase(ADDRESS_PAGE_27);
 179   1              e2rom_erase(ADDRESS_PAGE_28);
 180   1              e2rom_erase(ADDRESS_PAGE_29);*/ 
 181   1      
 182   1              switch(cType_Parameter){
 183   2      
 184   2                      case Parameter_Calibration:     //ok    
 185   2                              flash_write_u8(ADDR_SET_CALIBRATE, 1);
 186   2                              flash_write_float32(ADDR_CAPACITY_CALI, stScaleParam.fCapacityCali);
 187   2                              flash_write_float32(ADDR_POINT_ZERO, stScaleParam.fPointZeroCali);
 188   2                              flash_write_float32(ADDR_FACTOR_CALIBRATE, stScaleParam.fFactorCalibrate);
 189   2                              flash_write_u16(ADDR_COUNTER_CALIBRATION, stScaleParam.iCounter_Calibration);           
 190   2                              break;
 191   2                      
 192   2                      case Parameter_Count_Calibration:
 193   2                              flash_write_u16(ADDR_COUNTER_CALIBRATION, stScaleParam.iCounter_Calibration);           
 194   2                              break;
 195   2                              
 196   2                      case Parameter_Configuration:   
 197   2                              flash_write_u8(ADDR_LENGUAGE, stScaleParam.cLenguage);
 198   2                              flash_write_u8(ADDR_UNITS, stScaleParam.cUnits);                
 199   2                              flash_write_u16(ADDR_CAPACITY, stScaleParam.iCapacity);
 200   2                              flash_write_u16(ADDR_PORC_REF, stScaleParam.iLoadPorcRefer);
 201   2                              flash_write_u16(ADDR_DIVISION_MINIMA, stScaleParam.iDivisionMinima);    
 202   2                              flash_write_u16(ADDR_DIVISION_MENOR, stScaleParam.iDivisionMenor);
 203   2                              flash_write_u16(ADDR_DIVISION_MENORMENOR, stScaleParam.iDivisionMenorMenor);                    
 204   2                              flash_write_u8(ADDR_DECIMAL_TOTAL, stScaleParam.cPuntoDecimalTotal);
 205   2                              flash_write_u8(ADDR_REDONDEO_TOTAL, stScaleParam.cRedondeoCifraTotal);
 206   2                              flash_write_u8(ADDR_DECIMAL_PRECIO, stScaleParam.cPuntoDecimalPrecio);
 207   2                              flash_write_u8(ADDR_ZERO_TRACKING, stScaleParam.cZeroTracking);
 208   2                              flash_write_u8(ADDR_MSG_UNLOAD, stScaleParam.cMsgUnload);
 209   2                              flash_write_u8(ADDR_TIME_OFF, stScaleParam.cTimeAutooff);
 210   2                              flash_write_u8(ADDR_MODELO, stScaleParam.cModeloBascula);
 211   2                              flash_write_u8(ADDR_MSGBAT, stScaleParam.cShowHighBat);
 212   2                              flash_write_u16(ADDR_COUNTER_CONFIGURATION, stScaleParam.iCounter_Configuration);
 213   2                              flash_write_u8(ADDR_COUNT_RANGE, stScaleParam.cCountRange);
 214   2                              flash_write_u8(ADDR_MONEDA, stScaleParam.cMoneda);              
 215   2                              flash_write_u16(ADDR_COUNT_OVERLOAD, stScaleParam.iCountOverload);      
 216   2      
 217   2                              flash_write_float32(ADDR_VALUE_OVERLOAD, stScaleParam.fValueOverload);  
 218   2      
 219   2                              flash_write_u8(ADDR_DECIMAL_WEIGHT, stScaleParam.cWeightDecimal);       
 220   2                              flash_write_u8(ADDR_SAVEBATT, stScaleParam.cSaveBattery);                       
 221   2                              flash_write_u8(ADDR_ERRORBATT, srFlagScale.bShowErroBat);
 222   2                              flash_write_u8(ADDR_MULTIRANGO, stScaleParam.cMultirango);
 223   2      //                      flash_write_u8(ADDR_FORMATO_IMPRESION, stScaleParam.cFormatoImpresion);         
 224   2                              break;
 225   2              
 226   2                      case Parameter_Count_Configuration:
 227   2                              flash_write_u16(ADDR_COUNTER_CONFIGURATION, stScaleParam.iCounter_Configuration);
 228   2                              break;
 229   2                              
 230   2                      case Parameter_Point_Zero_Calibration:
 231   2                              flash_write_float32(ADDR_POINT_ZERO, stScaleParam.fPointZeroCali);                      
 232   2                              break;
 233   2                                      
 234   2              //      case Parameter_Debug:
 235   2              //              flash_write_u16(ADDR_DEBUG, stScaleParam.iDebug);
 236   2              //              break;
 237   2                                      
 238   2                      case Parameter_Overload:
 239   2                              flash_write_u16(ADDR_COUNT_OVERLOAD, stScaleParam.iCountOverload);              
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 5   

 240   2                              flash_write_float32(ADDR_VALUE_OVERLOAD, stScaleParam.fValueOverload);                                          
 241   2                              break;
 242   2                              
 243   2                      case Parameter_Voltages:
 244   2                              flash_write_float32(ADDR_VOLT_BATT, stScaleParam.fVoltage_Batt);
 245   2                              flash_write_float32(ADDR_VOLT_ADAP, stScaleParam.fVoltage_Adap);
 246   2                              break;
 247   2                      
 248   2              
 249   2                              
 250   2                      case Parameter_Register:
 251   2                              flash_write_float32(ADDR_VENTA_TOTAL, stScaleParam.fVenta_Total_Scale);
 252   2                              break;
 253   2      
 254   2                      case Parameter_Backlight:
 255   2                              flash_write_u8(ADDR_BACKLIGHT, stScaleParam.cBacklight);
 256   2                              break;
 257   2              }
 258   1              
 259   1              /* Deshabilita la escritura en la EEPROM */
 260   1              NRM_securty_a = 0x00;
 261   1              NRM_securty_b = 0x00;
 262   1      }
 263          
 264          /**
 265            ******************************************************************************
 266            * Objetivo: Encontrar un valor estable durante un tiempo X.
 267            * Parametros entrada: 
 268                  *               cSetCountBack -> Tiempo de muestreo (conteo descendente)
 269                  *               cShowCount -> Hacer visible el conteo.
 270                  *               cRunStable -> Llenar el filtro con el primer dato leido.
 271                  * Parametros Salida: Ninguno.
 272                  * Nota: Si durante la cuenta regrsiva el valor no esta dentro del rango
 273                  *       asignado, el conteo se reinicia.
 274            ******************************************************************************
 275            */
 276          float fStablePoint(unsigned char cSetCountBack, unsigned char cShowCount, unsigned char cRunStable){    
 277   1      
 278   1              unsigned char xdata cCountReading = 0;          /* Contador de lecturas */
 279   1              unsigned char xdata cNumber_Count = 0;
 280   1              long int xdata cCountBack = cSetCountBack;                      /* Contador de regresion */
 281   1              float xdata fActualWeightAdc=0;                                         /* Alamacena el peso actual valores adc */
 282   1              float xdata fWeightAdc = 0;                                                             /* Almacena el valor referencia */
 283   1              float xdata fLimitRange =  (float)stScaleParam.cCountRange;//5
 284   1              int i=0;
 285   1              
 286   1              cNumber_Count = 0;
 287   1              
 288   1              if(cRunStable == 0){
 289   2                      cNumber_Count = 2;
 290   2              }
 291   1              
 292   1              fWeightAdc = fRead_Adc(cRunStable);//delay_ms(100);     
 293   1              fWeightAdc = fRead_Adc(cRunStable);//delay_ms(100);
 294   1              fWeightAdc = fRead_Adc(cRunStable);//delay_ms(100);
 295   1              fWeightAdc = fRead_Adc(cRunStable);//delay_ms(100);
 296   1              
 297   1              while(cCountBack > -1){
 298   2                      
 299   2          vActionKey();
 300   2                      
 301   2                      /* Verifica si debe mostrar el contador en la LCD */
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 6   

 302   2                      if(cShowCount == 1){
 303   3                              if(cCountBack == 0){
 304   4                                      LCD_GLASS_String("00000", LCD_PESO);
 305   4                                      LCD_GLASS_String("00000", LCD_PRECIO);
 306   4                                      LCD_GLASS_String("000000", LCD_TOTAL);
 307   4                              }else{
 308   4                                      LCD_GLASS_Float(cCountBack*11111, 0, LCD_PESO);
 309   4                                      LCD_GLASS_Float(cCountBack*11111, 0, LCD_PRECIO);
 310   4                                      LCD_GLASS_Float(cCountBack*111111, 0, LCD_TOTAL);
 311   4                              }
 312   3                      }
 313   2              
 314   2                      fActualWeightAdc = fRead_Adc(cRunStable);
 315   2                      //delay_ms(100);
 316   2                      
 317   2                      /* Verica que el ultimo valor leido este dentro del rango del valor 
 318   2                              referencia */
 319   2                      if(fActualWeightAdc >= (fWeightAdc - fLimitRange) && 
 320   2                              fActualWeightAdc <= (fWeightAdc + fLimitRange)){
 321   3                                      cCountReading++;
 322   3                                      
 323   3                                      /* Si al completar 3 lecturas dentro del rango se decrementa el 
 324   3                                              contador */
 325   3                                      if(cCountReading > cNumber_Count){
 326   4                                              cCountBack--;
 327   4                                              cCountReading = 0;
 328   4                                      }                                       
 329   3                      }else{
 330   3                              /* Si el dato no esta dentro del rango, se toma una nueva referencia
 331   3                                      y se reinicia la cuenta regresiva */
 332   3                              if(cShowCount == 1){
 333   4                                      LCD_GLASS_Clear();
 334   4                                      LCD_GLASS_String("   UN", LCD_PRECIO);
 335   4                                      LCD_GLASS_String("STABLE", LCD_TOTAL);
 336   4                                      for(cCountBack=0; cCountBack<500; cCountBack++)delay_ms(1);
 337   4                              }
 338   3                              cCountReading = 0;
 339   3                              cCountBack = cSetCountBack;
 340   3                              fWeightAdc = fRead_Adc(cRunStable);
 341   3                              
 342   3                              if(cRunStable){
 343   4                                      srFlagScale.bFlagStable = 0;
 344   4                                      return (-100);
 345   4                              }
 346   3                      }
 347   2              }
 348   1              
 349   1              srFlagScale.bFlagStable = 1;
 350   1              return fWeightAdc;
 351   1      }
 352          
 353          /**
 354            ******************************************************************************
 355            * Objetivo: Calcular el numero de cuenta que se tomara como cero.
 356            * Parametros entrada: Ninguno.
 357                  * Parametros Salida: Ninguno.
 358            * Prerequisitos: Se usan las variables globales
 359                  *                       stScaleParam.cSetCalibrate, stScaleParam.fCapacityCali,  
 360                  *                       arDataDisplayLcd.
 361                  *       Modifica las variables globales:
 362                  *                       stScaleParam.fPointZero, arDataDisplayLcd.
 363            ******************************************************************************
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 7   

 364            */
 365          
 366          
 367            unsigned char cSetZeroPoint(void){    
 368   1      /*
 369   1      //////  unsigned char Value_Key_Press;
 370   1              float fWeightPlate = 0;         // Calcula el peso del plato en numero de cuentas 
 371   1              float fPointZero = 0;
 372   1                      
 373   1              fPointZero = fStablePoint(0, 0, 0);
 374   1              
 375   1              if(srFlagScale.bScaleOn == 0){
 376   1                      return 2;                               
 377   1              }
 378   1      
 379   1              //Se encuentra el peso actual del plato respecto al punto cero de calibracion 
 380   1              fWeightPlate = fPointZero - stScaleParam.fPointZeroCali;
 381   1              
 382   1              if(stScaleParam.cMsgUnload){
 383   1                      // Verifica los rangos para los distintos avisos 
 384   1                      if(((fWeightPlate > (stScaleParam.fCapacityCali * 0.20)) && (fWeightPlate < (stScaleParam.fCapacityCali 
             -* 0.50))) ||
 385   1                                      (fWeightPlate < (-1)*(stScaleParam.fCapacityCali * 0.20))){
 386   1                              
 387   1                              // Quita los simboloes de unidad de peso y Zero 
 388   1                              LCD_GLASS_Clear();
 389   1                              LCD_GLASS_String("  PLS", LCD_PESO);                            
 390   1                              LCD_GLASS_String("UNLOAD", LCD_TOTAL);  
 391   1                              
 392   1      ///////////                     //Auto_Off_On_5m;
 393   1                      
 394   1                              while(1){
 395   1                                      IWDG_KEY_REFRESH;
 396   1                                      if(srFlagScale.cWait_Time_Code || srFlagScale.bScaleOn == 0){
 397   1                                              return 2;                               
 398   1                                      }
 399   1                              }
 400   1                      }
 401   1              }
 402   1              
 403   1              if((fWeightPlate >= (stScaleParam.fCapacityCali * 0.50)) && fWeightPlate > 0){
 404   1                      
 405   1                      // Quita los simboloes de unidad de peso y Zero 
 406   1                      LCD_GLASS_Clear();      
 407   1                      LCD_GLASS_String("HELP ", LCD_PRECIO);  
 408   1              
 409   1                      //Auto_Off_On_5m;
 410   1                      
 411   1                      while(1){
 412   1                              IWDG_KEY_REFRESH;
 413   1                              if(srFlagScale.cWait_Time_Code || srFlagScale.bScaleOn == 0){
 414   1                                      return 2;                               
 415   1                              }
 416   1                      }
 417   1                                      
 418   1              }else{
 419   1                      stScaleParam.fPointZero = fPointZero;
 420   1              }
 421   1              
 422   1              
 423   1      */
 424   1      return 0;
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 8   

 425   1      }
 426          
 427          
 428          /**
 429            ******************************************************************************
 430            * Objetivo: Activar/Desactivar el uso de la Tara.
 431            * Parametros entrada: 
 432                  *               cActionTara -> Accion a ejecutar (ON) Activa la Tara, 
 433            *                                                                                                                                             (OFF) Desactiva la Tara.
 434                  * Parametros Salida: Retorna
 435                  *               (0) Para indicar que no se proceso la orden.
 436                  *               (1) Para indicar que se Desactivo o Activo la Tara.
 437            * Prerequisitos: Se usan las variables globales
 438                  *                       stScaleParam.fCapacityCali.
 439                  *       Modifica las variables globales:
 440                  *               stScaleParam.fPointZeroTara, stScaleParam.fPointZero.
 441            ******************************************************************************
 442            */
 443          void cOnOffModeTara(float fWeightTara){
 444   1              
 445   1      /*      float fAdcCountTara = 0; 
 446   1              float fLimite_Inf = 0;
 447   1              float fLimite_Sup = 0;
 448   1              float fWeightZero = 0;
 449   1              float AuxTara = 0;
 450   1              
 451   1              fWeightZero = fStablePoint(1, 0, 1);
 452   1              
 453   1              if(srFlagScale.bFlagStable == 1){
 454   1              
 455   1                      if(fWeightTara > 0){
 456   1                              if(srFlagScale.bTara == 0){     
 457   1                                      
 458   1                                      if(stScaleParam.cUnits == UNIT_LB){
 459   1                                              if(fCuentasToPeso(stScaleParam.fWeightScaleTara) <= stScaleParam.iCapacity){
 460   1                                                      stScaleParam.fValueTara = stScaleParam.fWeightScaleTara;
 461   1                                                      srFlagScale.bTara = 1;
 462   1                                              }
 463   1                                      }else{
 464   1                                              if(fCuentasToPeso(stScaleParam.fWeightScaleTara) <= 9.999){
 465   1                                                      stScaleParam.fValueTara = stScaleParam.fWeightScaleTara;
 466   1                                                      srFlagScale.bTara = 1;
 467   1                                              }
 468   1                                      }
 469   1                              }else{
 470   1                                      if(stScaleParam.cUnits == UNIT_LB){
 471   1                                              if(fCuentasToPeso(stScaleParam.fWeightScaleTara) <= stScaleParam.iCapacity){
 472   1                                                      stScaleParam.fValueTara = stScaleParam.fWeightScaleTara;
 473   1                                              }
 474   1                                      }else{
 475   1                                              if(fCuentasToPeso(stScaleParam.fWeightScaleTara) < 9.999){
 476   1                                                      stScaleParam.fValueTara = stScaleParam.fWeightScaleTara;
 477   1                                              }
 478   1                                      }
 479   1                              }
 480   1                      }else if(fWeightTara < 0){
 481   1                              
 482   1                              if(srFlagScale.bTara){
 483   1                                      fWeightTara *= (-1);
 484   1                                      
 485   1                                      if(stScaleParam.cMultirango == 1){
 486   1                                              if(stScaleParam.fValueTara <= stScaleParam.fCapacityCali*0.2){
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 9   

 487   1                                                              AuxTara = stScaleParam.fFactorCalibrate / stScaleParam.iDivisionMinima;
 488   1                                                              AuxTara *= stScaleParam.iDivisionMenor;
 489   1                                                              fLimite_Inf = fCuentasToPeso(stScaleParam.fValueTara - 3*AuxTara);
 490   1                                                              fLimite_Sup = fCuentasToPeso(stScaleParam.fValueTara + 3*AuxTara);
 491   1                                                      }else{
 492   1                                                              fLimite_Inf = fCuentasToPeso(stScaleParam.fValueTara - 3*stScaleParam.fFactorCalibrate);
 493   1                                                              fLimite_Sup = fCuentasToPeso(stScaleParam.fValueTara + 3*stScaleParam.fFactorCalibrate);
 494   1                                                      }
 495   1                                      }else{
 496   1                                              fLimite_Inf = fCuentasToPeso(stScaleParam.fValueTara - 3*stScaleParam.fFactorCalibrate);
 497   1                                              fLimite_Sup = fCuentasToPeso(stScaleParam.fValueTara + 3*stScaleParam.fFactorCalibrate);
 498   1                                      }
 499   1                                              
 500   1                                      if((fWeightTara >= fLimite_Inf) && (fWeightTara <= fLimite_Sup)){
 501   1                                              LCD_GLASS_Symbols(SYMBOL_NET, 0);
 502   1                                              stScaleParam.fValueTara = 0;
 503   1                                              srFlagScale.bTara = 0;
 504   1                                              stScaleParam.fPointZero = stScaleParam.fWeightScaleCount;
 505   1                                              fFilter_Averaging(fWeightZero, 1);      //Ingresa el dato al filtro 
 506   1                                      }
 507   1                              }
 508   1                      }
 509   1                      
 510   1              }*/
 511   1      }
*** WARNING C280 IN LINE 443 OF _SCALE\DVR_SCALE.C: 'fWeightTara': unreferenced local variable
 512          
 513          /**
 514            ******************************************************************************
 515            * Objetivo: Establecer el punto Zero
 516            * Parametros entrada: Ninguno
 517                  * Parametros Salida: Retorna
 518            ******************************************************************************
 519            */
 520          void vSetZero(void){
 521   1              float xdata fWeightZero = 0;
 522   1              
 523   1              /* Verifica si el peso es estable para volver cero */
 524   1              fWeightZero = fStablePoint(1, 0, 1);
 525   1                      
 526   1              if(srFlagScale.bFlagStable == 1){               
 527   2                      stScaleParam.fPointZero = fWeightZero;
 528   2              }
 529   1      }
 530          
 531          /**
 532            ******************************************************************************
 533            * Objetivo: Establecer el punto Zero dinamico
 534            * Parametros entrada: Ninguno
 535                  * Parametros Salida: Ninguno
 536            ******************************************************************************
 537            */
 538          void vGetZeroTracking(float fActualWeightScale){
 539   1      /*      float fValor_Limite = 0;
 540   1              
 541   1              
 542   1              if(stScaleParam.cMultirango == 1){
 543   1                      fValor_Limite = stScaleParam.fFactorCalibrate/stScaleParam.iDivisionMinima;
 544   1                      fValor_Limite *= stScaleParam.iDivisionMenorMenor;
 545   1              }else   
 546   1                      fValor_Limite = stScaleParam.fFactorCalibrate;
 547   1              
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 10  

 548   1              fValor_Limite /= 2; 
 549   1              
 550   1              if(fValor_Limite < 0){
 551   1                      fValor_Limite *= (-1);
 552   1              }
 553   1              
 554   1              if(fActualWeightScale > (stScaleParam.fPointZero - fValor_Limite) &&
 555   1                      fActualWeightScale < (stScaleParam.fPointZero + fValor_Limite)){
 556   1                      
 557   1                      iCounterZeroTracking++;
 558   1                      if(iCounterZeroTracking >=15){
 559   1                              stScaleParam.fPointZero = fActualWeightScale;
 560   1                      }
 561   1              }else{
 562   1                      iCounterZeroTracking = 0;
 563   1              }*/
 564   1      }
*** WARNING C280 IN LINE 538 OF _SCALE\DVR_SCALE.C: 'fActualWeightScale': unreferenced local variable
 565          
 566          /**
 567            ******************************************************************************
 568            * Objetivo: Ejecutar el proceso de calibracion de la bascula 
 569            * Parametros entrada:  
 570                  * Parametros Salida:
 571            * Prerequisitos: 
 572            ******************************************************************************
 573            */
 574          void vCalibrate_Scale(void){
 575   1                    float xdata fAux_Value = 0;
 576   1                    float xdata fAuxCountAdcInicial = 0;
 577   1                    float xdata fAuxCountAdcFinal = 0;
 578   1                    float xdata fAuxCountDif = 0;
 579   1                    
 580   1                    stScaleParam.iCounter_Calibration++;  /* Aumenta el contador de calibraciones */ 
 581   1                    vSaveParamScale(Parameter_Calibration);                                                     
             -                                         /*Almacena los parametros en la E2prom*/
 582   1                                  
 583   1                    LCD_GLASS_Clear();
 584   1      #if DISPLAY_20400047_EN > 0
 585   1        LCD_GLASS_String("PRESS", LCD_PESO);
 586   1                    LCD_GLASS_String("REF 0", LCD_TOTAL);
 587   1                    LCD_GLASS_String("C", LCD_PRECIO);
 588   1      #else     
                LCD_GLASS_String("PRESS", LCD_PRECIO);
                            LCD_GLASS_String("REF 0", LCD_PESO);
                            LCD_GLASS_String("C", LCD_TOTAL);
              #endif
 593   1              
 594   1                    /* Espera a que se oprima 'C' para continuar */
 595   1                    Key=0;while(Key!= KEY_C)key_scan();
 596   1                                Key=0;while(Key== KEY_C)key_scan();
 597   1                    delay_ms(1000);            
 598   1      
 599   1                    /* Solicita la referencia de zero */
 600   1                    stScaleParam.fPointZeroCali = fStablePoint(5, 1, 0);
 601   1                                //LCD_GLASS_Float(stScaleParam.fPointZeroCali, 2, LCD_TOTAL);delay_ms(5000);
 602   1                    
 603   1                    fAuxCountAdcInicial = stScaleParam.fPointZeroCali;
 604   1                                //borrar  //CCC  
 605   1      
 606   1                    LCD_GLASS_Clear();
 607   1      #if DISPLAY_20400047_EN > 0
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 11  

 608   1                    LCD_GLASS_String("PRESS", LCD_PESO);
 609   1                    LCD_GLASS_String(" LOAD", LCD_TOTAL);
 610   1                    LCD_GLASS_String("C   ", LCD_PRECIO);
 611   1      #else
                            LCD_GLASS_String("PRESS", LCD_PRECIO);
                            LCD_GLASS_String(" LOAD", LCD_PESO);
                            LCD_GLASS_String("C     ", LCD_TOTAL);
              #endif
 616   1      
 617   1       /* Espera a que se oprima 'C' para continuar */
 618   1                    Key=0;while(Key!= KEY_C)key_scan();
 619   1      
 620   1                    stScaleParam.fCapacityCali = fStablePoint(5, 1, 0);
 621   1                                //LCD_GLASS_Float(stScaleParam.fCapacityCali, 2, LCD_TOTAL);delay_ms(5000);
 622   1                   
 623   1                    
 624   1                    fAuxCountAdcFinal = stScaleParam.fCapacityCali;
 625   1                    
 626   1                    fAuxCountDif = (fAuxCountAdcFinal - fAuxCountAdcInicial);
 627   1                    fAuxCountDif    *= (100/stScaleParam.iLoadPorcRefer);
 628   1      
 629   1                    //LCD_GLASS_Float(stScaleParam.iLoadPorcRefer, 2, LCD_TOTAL);delay_ms(5000);
 630   1      
 631   1                    stScaleParam.fCapacityCali -= stScaleParam.fPointZeroCali;
 632   1                    stScaleParam.fCapacityCali *= (100/stScaleParam.iLoadPorcRefer);
 633   1                    
 634   1                    stScaleParam.fFactorCalibrate = (float)(stScaleParam.fCapacityCali);
 635   1                    fAux_Value = (float)(stScaleParam.iCapacity);
 636   1                    fAux_Value *= pow(10,(int)stScaleParam.cWeightDecimal);
 637   1                    fAux_Value = (float)(fAux_Value)/(float)(stScaleParam.iDivisionMinima);
 638   1                    stScaleParam.fFactorCalibrate /= fAux_Value;
 639   1                    
 640   1                    if(stScaleParam.fCapacityCali < 0){
 641   2                                  stScaleParam.fCapacityCali *= (-1);
 642   2                    }
 643   1      
 644   1                    LCD_GLASS_Clear();     
 645   1      #if DISPLAY_20400047_EN > 0
 646   1                    LCD_GLASS_String("FACTO", LCD_PESO);
 647   1                                LCD_GLASS_Float(stScaleParam.fFactorCalibrate, 2, LCD_TOTAL);
 648   1                                LCD_GLASS_String("R", LCD_TOTAL);
 649   1                    LCD_GLASS_Dot(2, LCD_TOTAL, 1);
 650   1                    LCD_GLASS_String("  END", LCD_PRECIO);          
 651   1      #else
                            LCD_GLASS_String("  END", LCD_PESO);
                            LCD_GLASS_Float(stScaleParam.fFactorCalibrate, 2, LCD_TOTAL);     
                                        LCD_GLASS_String("R", LCD_TOTAL);
                            LCD_GLASS_Dot(2, LCD_TOTAL, 1);
                            LCD_GLASS_String("FACTO", LCD_PRECIO);
              #endif
 658   1      
 659   1      
 660   1      
 661   1      
 662   1      ////////////////////////////////////////////////////////////////////////////              
 663   1                    /*Almacena los parametros en la E2prom*/       
 664   1                    vSaveParamScale(Parameter_Calibration);                                        
 665   1                    
 666   1      ///////////CCCCC/////////////CCCCC/////////////CCCCC/////////////CCCCC/////////////CCCCC//              vS
             -et_Volts_System();    
 667   1                    vSaveParamScale(Parameter_Voltages);
 668   1                    
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 12  

 669   1      ///////////CCCCC//BORRAR DE LA ESTRUCTURA ///////////////////////////////////           stScaleParam.fTemp
             -erature = fGet_Temp_Amb_Micro();
 670   1      //              vSaveParamScale(Parameter_Temperature);
 671   1      
 672   1          vSound_Saved_Param();
 673   1                    vSound_Saved_Param();
 674   1                    
 675   1                    //strTimer.cFLag_TimerE_Start = 1;
 676   1                   // strTimer.cFLag_TimerE_End = 0;
 677   1                    
 678   1                    //while(!strTimer.cFLag_TimerE_End)key_scan();
 679   1                                delay_ms(5000);
 680   1      
 681   1                                //Key=0;while(Key!= KEY_C)key_scan();
 682   1                    
 683   1                    LCD_GLASS_Clear();
 684   1      }
 685          
 686          
 687          /**
 688            ******************************************************************************
 689            * Objetivo: Configurar valores por default.
 690            * Parametros entrada:  
 691                  * Parametros Salida:
 692            * Prerequisitos: 
 693            ******************************************************************************
 694            */
 695          void vPreConfiguration(unsigned char cPreConfiguration){
 696   1              
 697   1      //      enum    digi_key Value_Key_Press;
 698   1              unsigned char xdata cIndex = 0;
 699   1              
 700   1      //      strTimer.cFLag_TimerD_Start = 1;
 701   1              
 702   1              LCD_GLASS_Clear();
 703   1              
 704   1              stScaleParam.cMultirango = 1;
 705   1              stScaleParam.cLenguage = ESPANOL;
 706   1              
 707   1              if(cPreConfiguration == PreConfig15KG){
 708   2                      stScaleParam.iCapacity = 15;
 709   2                      stScaleParam.iDivisionMinima = 5;
 710   2                      stScaleParam.iDivisionMenor = 2;
 711   2                      stScaleParam.iDivisionMenorMenor = 1;
 712   2                      stScaleParam.cWeightDecimal = 3;
 713   2                      stScaleParam.cUnits = UNIT_KG;
 714   2                      LCD_GLASS_Symbols(SYMBOL_KG, 1);
 715   2                      stScaleParam.cMoneda = MONEDA_PESOS;
 716   2              }else if(cPreConfiguration == PreConfig20KG){
 717   2                      stScaleParam.iCapacity = 20;
 718   2                      stScaleParam.iDivisionMinima = 5;
 719   2                      stScaleParam.iDivisionMenor = 2;
 720   2                      stScaleParam.iDivisionMenorMenor = 1;
 721   2                      stScaleParam.cWeightDecimal = 3;
 722   2                      stScaleParam.cUnits = UNIT_KG;
 723   2                      LCD_GLASS_Symbols(SYMBOL_KG, 1);
 724   2                      stScaleParam.cMoneda = MONEDA_PESOS;
 725   2              }else if(cPreConfiguration == PreConfig30KG){
 726   2                      stScaleParam.iCapacity = 30;
 727   2                      stScaleParam.iDivisionMinima = 10;
 728   2                      stScaleParam.iDivisionMenor = 5;
 729   2                      stScaleParam.iDivisionMenorMenor = 2;
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 13  

 730   2                      stScaleParam.cWeightDecimal = 3;
 731   2                      stScaleParam.cUnits = UNIT_KG;
 732   2                      LCD_GLASS_Symbols(SYMBOL_KG, 1);
 733   2                      stScaleParam.cMoneda = MONEDA_PESOS;
 734   2              }else if(cPreConfiguration == PreConfig31KG){
 735   2                      stScaleParam.iCapacity = 30;
 736   2                      stScaleParam.iDivisionMinima = 5;
 737   2                      stScaleParam.iDivisionMenor = 2;
 738   2                      stScaleParam.iDivisionMenorMenor = 1;
 739   2                      stScaleParam.cWeightDecimal = 3;
 740   2                      stScaleParam.cUnits = UNIT_KG;
 741   2                      LCD_GLASS_Symbols(SYMBOL_KG, 1);
 742   2                      stScaleParam.cMoneda = MONEDA_PESOS;            
 743   2              }else if(cPreConfiguration == PreConfig32KG){
 744   2                      stScaleParam.iCapacity = 30;
 745   2                      stScaleParam.iDivisionMinima = 2;
 746   2                      stScaleParam.iDivisionMenor = 2;
 747   2                      stScaleParam.iDivisionMenorMenor = 2;
 748   2                      stScaleParam.cMultirango = 0;
 749   2                      stScaleParam.cWeightDecimal = 3;
 750   2                      stScaleParam.cUnits = UNIT_KG;
 751   2                      LCD_GLASS_Symbols(SYMBOL_KG, 1);
 752   2                      stScaleParam.cMoneda = MONEDA_PESOS;            
 753   2              }else if(cPreConfiguration == PreConfig40KG){
 754   2                      stScaleParam.iCapacity = 40;
 755   2                      stScaleParam.iDivisionMinima = 10;
 756   2                      stScaleParam.iDivisionMenor = 5;
 757   2                      stScaleParam.iDivisionMenorMenor = 2;
 758   2                      stScaleParam.cWeightDecimal = 3;
 759   2                      stScaleParam.cUnits = UNIT_KG;
 760   2                      LCD_GLASS_Symbols(SYMBOL_KG, 1);
 761   2                      stScaleParam.cMoneda = MONEDA_PESOS;
 762   2              }else if(cPreConfiguration == PreConfig60LB){
 763   2                      stScaleParam.iCapacity = 60;
 764   2                      stScaleParam.iDivisionMinima = 2;
 765   2                      stScaleParam.cWeightDecimal = 2;
 766   2                      stScaleParam.cUnits = UNIT_LB;
 767   2                      stScaleParam.cLenguage = ENGLISH;
 768   2                      LCD_GLASS_Symbols(SYMBOL_LB, 1);
 769   2                      stScaleParam.cMoneda = MONEDA_DLLS;
 770   2                      stScaleParam.cMultirango = 0;
 771   2              }
 772   1              
 773   1              LCD_GLASS_Float(stScaleParam.iCapacity, stScaleParam.cWeightDecimal, LCD_PESO);
 774   1              
 775   1              stScaleParam.iLoadPorcRefer = 100;
 776   1              stScaleParam.cPuntoDecimalTotal = 2;
 777   1              stScaleParam.cRedondeoCifraTotal = 1;
 778   1              stScaleParam.cPuntoDecimalPrecio = 3;
 779   1              stScaleParam.cValorcRedondeoCifraVentaTotal = 0;
 780   1              stScaleParam.cZeroTracking = 1;
 781   1              stScaleParam.cMsgUnload = 1;
 782   1              stScaleParam.cTimeAutooff = 1;
 783   1              stScaleParam.cShowHighBat = 1;
 784   1              stScaleParam.cModeIncDiv = 0;
 785   1              stScaleParam.cCountRange = 5;
 786   1              stScaleParam.iCountOverload = 0;                
 787   1              stScaleParam.fValueOverload = 0;
 788   1              stScaleParam.cSaveBattery       = 0;
 789   1      //  stScaleParam.cFormatoImpresion = 2; 
 790   1              stScaleParam.cTypeBeeper = 0;
 791   1              
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 14  

 792   1              stScaleParam.fVoltage_Batt = 0;
 793   1              stScaleParam.fVoltage_Adap = 0;
 794   1              
 795   1              stScaleParam.fCapacityCali = 0;
 796   1              stScaleParam.fPointZeroCali = 0;
 797   1              stScaleParam.fFactorCalibrate = 0;
 798   1              srFlagScale.bShowErroBat = 1;
 799   1      
 800   1              
 801   1              stScaleParam.fVenta_Total_Scale = 0;
 802   1              stScaleParam.iCounter_Calibration = 0;
 803   1              stScaleParam.iCounter_Configuration = 0;
 804   1      
 805   1              strTimer.iTimerE=1;
 806   1              Key_scan();
*** WARNING C206 IN LINE 806 OF _SCALE\DVR_SCALE.C: 'Key_scan': missing function-prototype
 807   1              
 808   1              /* Espera a que se oprima la tecla 'MEM' o que pase el tiempo de 5 seg  */
 809   1              while((Key != KEY_MEM) && strTimer.iTimerE < TimerEend){
 810   2                      Key_scan();//Value_Key_Press = vActionKey();
 811   2              }       
 812   1              
 813   1              if(strTimer.iTimerE >= TimerEend){
 814   2                      LCD_GLASS_Clear();
 815   2                      return;
 816   2              }
 817   1              
 818   1      
 819   1                      vSaveParamScale(Parameter_Voltages); 
 820   1                      
 821   1                       vSaveParamScale(Parameter_Calibration);
 822   1                      vSaveParamScale(Parameter_Register);
 823   1                      vSaveParamScale(Parameter_Configuration);
 824   1      
 825   1                      LCD_GLASS_String("SAVED", LCD_PRECIO);
 826   1                      vSound_Saved_Param();
 827   1                      vSound_Saved_Param();
 828   1                      
 829   1      
 830   1                      Key_scan();
 831   1                      
 832   1                      /* Espera a que se oprima la tecla 'MEM' o que pase el tiempo de 5 seg  */
 833   1                      while((Key != KEY_MEM) && strTimer.iTimerE < TimerEend)
 834   1                              Key_scan();//Value_Key_Press = vActionKey();
 835   1                              
 836   1      
 837   1                      
 838   1                      
 839   1                      if(Key == KEY_MEM){
 840   2              //      vSpecial_Action(Funcion_Especial);
 841   2                      }
 842   1              
 843   1              
 844   1              LCD_GLASS_Clear();
 845   1              //LCD_GLASS_String("  OFF", LCD_PRECIO);
 846   1      
 847   1      
 848   1      //      strTimer.iTimerE=1;     
 849   1              /* Espera a que se oprima la tecla 'MEM' o que pase el tiempo de 5 seg  */
 850   1      //      while(strTimer.iTimerE < TimerEend){
 851   1      //              Key_scan();//Value_Key_Press = vActionKey();
 852   1      //      }       
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 15  

 853   1                                      
 854   1              return;
 855   1      }
 856          
 857          
 858          /**
 859            ******************************************************************************
 860            * Objetivo: Calcular peso y registrar precio del producto 
 861            * Parametros entrada:
 862                  * Parametros Salida:
 863            * Prerequisitos: 
 864            ***
 865                  */
 866          unsigned char cRun_Scale(unsigned char bEnableKeys){
 867   1      
 868   1      /*
 869   1      //      enum    digi_key Value_Key_Press;
 870   1              
 871   1              // Lee teclado y ejecuta las acciones correspondientes 
 872   1              if(bEnableKeys == 1){
 873   1                      vScan_Key();
 874   1              }
 875   1                      
 876   1              if(srFlagScale.cAuto_Off_Time == 1 && stScaleParam.cTimeAutooff == 1){
 877   1                      srFlagScale.bScaleOn = 0;
 878   1                      return 0;
 879   1              }
 880   1              
 881   1      ///////////////CCC//////////////////////7777777 vGestorBateria();
 882   1              
 883   1              if(srFlagScale.bMsgBatteryLow == 1){
 884   1                      return 0;
 885   1              }
 886   1      
 887   1              if(srFlagScale.bOverLoad ==0){
 888   1                      if(srFlagScale.bSourceVoltage ==  SOURCE_ADAPTER){
 889   1                              LCD_GLASS_Symbols(SYMBOL_Y, 1);
 890   1                      }else{
 891   1                              LCD_GLASS_Symbols(SYMBOL_Y, 0);
 892   1                      }
 893   1              }
 894   1                                      
 895   1              srFlagScale.bFlagWeightNeg = 0;                 // Clarea indicador de peso negativo 
 896   1      
 897   1      ///////////7CCCCCC //CCC        //CCC vCalculate_Weight();
 898   1      
 899   1              if(srFlagScale.bErrorResponseAdc == 1 || srFlagScale.bErrorReadAdc == 1){               
 900   1                      LCD_GLASS_String("-----", LCD_PESO);
 901   1                      LCD_GLASS_String("    -", LCD_PRECIO);
 902   1                      LCD_GLASS_String("     -", LCD_TOTAL);
 903   1                      LCD_GLASS_Symbols(SYMBOL_ALL, 0);               
 904   1                      return 0;
 905   1              }
 906   1              
 907   1                      if(srFlagScale.bErrorNoiseAdc == 1){            
 908   1                      LCD_GLASS_String("-----", LCD_PESO);
 909   1                      LCD_GLASS_String("  ---", LCD_PRECIO);
 910   1                      LCD_GLASS_String("   ---", LCD_TOTAL);
 911   1                      LCD_GLASS_Symbols(SYMBOL_ALL, 0);               
 912   1                      return 0;
 913   1              }
 914   1              
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 16  

 915   1              if(srFlagScale.bOverLoad ==0){
 916   1                      
 917   1                      if(srFlagScale.bActiveSaveBattery == 1 && stScaleParam.cZeroTracking == 1 && 
 918   1                              fWeightScale == 0 && stScaleParam.cSaveBattery == 1 &&
 919   1                                      srFlagScale.bSourceVoltage !=  SOURCE_ADAPTER && srFlagScale.bTara == 0){
 920   1                              fSleep_Run();
 921   1                              
 922   1                              //CCC vCalculate_Weight();
 923   1                              
 924   1                              if(srFlagScale.bScaleOn == 0){
 925   1                                      return 0;
 926   1                              }
 927   1                      }
 928   1                      
 929   1                      // Verifica si esta la opcion fijar precio para mostrar indicador
 930   1                      if(srFlagScale.bFlagFijarPRecio){
 931   1                              LCD_GLASS_Symbols(SYMBOL_X, 1);
 932   1                      }else{
 933   1                              LCD_GLASS_Symbols(SYMBOL_X, 0);
 934   1                      }
 935   1                      
 936   1                      // Verfica el tipo de unidades a mostrar
 937   1                      if(stScaleParam.cUnits == UNIT_KG){
 938   1                              LCD_GLASS_Symbols(SYMBOL_KG, 1);
 939   1                      }else if(stScaleParam.cUnits == UNIT_LB){
 940   1                              LCD_GLASS_Symbols(SYMBOL_LB, 1);
 941   1                      }
 942   1                      
 943   1                      if(fWeightScale > -0.0005 && fWeightScale < 0.0005){
 944   1                              LCD_GLASS_Symbols(SYMBOL_ZERO, 1);
 945   1                      }else{
 946   1                              LCD_GLASS_Symbols(SYMBOL_ZERO, 0);
 947   1                              //Restart_Sleep_Time;
 948   1                      }
 949   1              }
 950   1                      
 951   1              srFlagScale.bFlagNeg = 0;       
 952   1              
 953   1              if(srFlagScale.bShowCountADC){
 954   1                      
 955   1                      vWeight_Positive();
 956   1                      
 957   1              }else{
 958   1                      // Verifica si el peso es negativo
 959   1                      if(fWeightScale < 0){
 960   1                              vWeight_Negative();                     
 961   1                      }else{                  
 962   1                              vWeight_Positive();                     
 963   1                      }
 964   1              }
 965   1              
 966   1                      if(srFlagScale.bTara){
 967   1                              if((fWeightLight >= stScaleParam.fValueTara+20*stScaleParam.fFactorCalibrate) && srFlagScale.bBateriaLo
             -w == 0){
 968   1                                      if(stScaleParam.cBacklight){OnBackLight;}
 969   1                                      strTimer.iTimerJ = 1;
 970   1                                      srFlagScale.bBacklight_On = 1;
 971   1                              }else{
 972   1                                      if(srFlagScale.bSourceVoltage != SOURCE_ADAPTER && strTimer.iTimerJ >= TimerJend){
 973   1                                              OffBackLight;
 974   1                                              srFlagScale.bBacklight_On = 0;
 975   1                                      }
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 17  

 976   1                              }
 977   1                              
 978   1                      }else{
 979   1                              if((fWeightLight >= stScaleParam.fPointZero+20*stScaleParam.fFactorCalibrate) && srFlagScale.bBateriaLo
             -w == 0){
 980   1                                              if(stScaleParam.cBacklight){OnBackLight;}
 981   1                                              strTimer.iTimerJ = 1;
 982   1                                              srFlagScale.bBacklight_On = 1;
 983   1                                      }else{
 984   1                                              if(srFlagScale.bSourceVoltage != SOURCE_ADAPTER && strTimer.iTimerJ >= TimerJend){
 985   1                                                      OffBackLight;
 986   1                                                      srFlagScale.bBacklight_On = 0;
 987   1                                      }
 988   1                              }
 989   1                      } 
 990   1              
 991   1      */
 992   1              return 0;
 993   1      }
*** WARNING C280 IN LINE 866 OF _SCALE\DVR_SCALE.C: 'bEnableKeys': unreferenced local variable
 994          
 995          /**
 996            ******************************************************************************
 997            * Objetivo: Funcionamiento normal con peso mayor igual a cero 
 998            * Parametros entrada:
 999                  * Parametros Salida:
1000            * Prerequisitos: 
1001            ***
1002                  */
1003          void vWeight_Positive(void){
1004   1              
1005   1      /*      float fWeightOverload = 0;
1006   1              
1007   1              float fOverloadUnit =  (float)stScaleParam.iCapacity + 
1008   1                                              ((float)(stScaleParam.iDivisionMinima)/(float)(pow(10, (int)stScaleParam.cWeightDecimal)))*9;
1009   1              
1010   1      /////////////CCC/////////////CCC/////////////CCC/////////////CCC        fOverloadUnit = fRoundFloat(fOverloadUnit
             -, (int)stScaleParam.cWeightDecimal, stScaleParam.iDivisionMinima);
1011   1              
1012   1              fWeightOverload = stScaleParam.fWeightScaleCount-stScaleParam.fPointZeroInitial;
1013   1              
1014   1              // Verifca que no exista la condicion de sobrepeso 
1015   1              if((fWeightOverload > stScaleParam.fWeightOverload || stScaleParam.fWeightScale > fOverloadUnit)  &&
1016   1                              srFlagScale.bTopeSobrePeso == 0){
1017   1                              
1018   1                      if(srFlagScale.bOverLoad == 0){
1019   1                              stScaleParam.iCountOverload++;          
1020   1                              vSaveParamScale(Parameter_Overload);
1021   1                      }
1022   1                      
1023   1                      srFlagScale.bOverLoad = 1;
1024   1                      
1025   1                      vGestorBateria();
1026   1                      
1027   1                      // Cuando existe sobrepeso lo indica en la LCD
1028   1                      LCD_GLASS_Symbols(SYMBOL_ALL, 0);
1029   1                      LCD_GLASS_String("      ", LCD_TOTAL);
1030   1                      
1031   1                      if(stScaleParam.cLenguage == ESPANOL){
1032   1                              LCD_GLASS_String("SOBRE", LCD_PESO);
1033   1                              LCD_GLASS_String(" PESO", LCD_PRECIO);
1034   1                      }else{
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 18  

1035   1                              LCD_GLASS_String("OVER ", LCD_PESO);
1036   1                              LCD_GLASS_String(" LOAD", LCD_PRECIO);
1037   1                      }
1038   1                      
1039   1                      strTimer.iTimerA= 1;
1040   1                      while(strTimer.iTimerA<TimerAend){
1041   1                              IWDG_KEY_REFRESH;
1042   1                      }       
1043   1                      
1044   1                      if(stScaleParam.fWeightScaleCount-stScaleParam.fPointZeroInitial > stScaleParam.fValueOverload){
1045   1                              stScaleParam.fValueOverload = stScaleParam.fWeightScaleCount-stScaleParam.fPointZeroInitial;
1046   1                              vSaveParamScale(Parameter_Overload);
1047   1                      }
1048   1                      
1049   1                      //Restart_Sleep_Time;
1050   1                      
1051   1              }else{
1052   1                      srFlagScale.bOverLoad = 0;
1053   1                      
1054   1                      // Despliega el peso registrado
1055   1                      LCD_GLASS_Float(stScaleParam.fWeightScale, (int)stScaleParam.cWeightDecimal, LCD_PESO);
1056   1                                              
1057   1                      // Verifica si la opcion fijar precio no esta activada
1058   1                      if(!srFlagScale.bFlagFijarPRecio){
1059   1                              if(stScaleParam.fWeightScale == 0 && fWeightScaleBefore > 0){
1060   1                                      stScaleParam.fPrice_Unit = 0;
1061   1                                      stScaleParam.cNumberDecimalPrice = 0;
1062   1                                      srFlagScale.bDotDecimalPrice = 0;
1063   1                                      stScaleParam.cNumberDecimalPrice = 0;
1064   1                              }
1065   1                      }
1066   1                      
1067   1                      if(stScaleParam.fWeightScale != fWeightScaleBefore){
1068   1                              //Auto_Off_On_15m;
1069   1                              //Restart_Sleep_Time;
1070   1                      }
1071   1                              
1072   1                      fWeightScaleBefore = stScaleParam.fWeightScale;
1073   1                      
1074   1                      // Muestra el precio x unidad del producto
1075   1                      if(stScaleParam.fWeightScale == 0 && srFlagScale.bFlagFijarPRecio == 0 && srFlagScale.bPrecioCero == 0){
1076   1                              srFlagScale.bPrecioCero = 1;
1077   1                      }
1078   1                      
1079   1                      if(stScaleParam.cPuntoDecimalPrecio < 3){
1080   1                              LCD_GLASS_Float(stScaleParam.fPrice_Unit, stScaleParam.cPuntoDecimalPrecio, LCD_PRECIO);
1081   1                      }else{
1082   1                              LCD_GLASS_Float(stScaleParam.fPrice_Unit, stScaleParam.cNumberDecimalPrice, LCD_PRECIO);
1083   1                      }
1084   1                      
1085   1                      stScaleParam.fTotal_Venta = stScaleParam.fPrice_Unit * stScaleParam.fWeightScale;
1086   1                                              
1087   1              /////////CCC/////////CCC/////////CCC/////////CCC/////////CCC stScaleParam.fTotal_Venta = fRoundFlo
             -at(stScaleParam.fTotal_Venta, 
1088   1                       /////////CCC/////////CCC/////////CCC/////////CCC//////  stScaleParam.cPuntoDecimalTotal, stScaleParam.c
             -ValorRedondeoCifraTotal);
1089   1                      
1090   1                      //Verifica si el valor del total excede el limite a mostrar en la LCD
1091   1                      if(stScaleParam.fTotal_Venta > (999999 / (float)(pow(10,stScaleParam.cPuntoDecimalTotal)))){
1092   1                              LCD_GLASS_String("------", LCD_TOTAL);
1093   1                      }else{
1094   1                              if(stScaleParam.fTotal_Venta > 0){
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 19  

1095   1                                      LCD_GLASS_Float(stScaleParam.fTotal_Venta, stScaleParam.cPuntoDecimalTotal, LCD_TOTAL);
1096   1                              }else{
1097   1                                      LCD_GLASS_Float(0, 0, LCD_TOTAL);
1098   1                              }
1099   1                      }
1100   1              }*/
1101   1      }
1102          
1103          /**
1104            ******************************************************************************
1105            * Objetivo: Bloqueo del sistema por peso negativo 
1106            * Parametros entrada:
1107                  * Parametros Salida:
1108            * Prerequisitos: 
1109            ***
1110                  */
1111          void vWeight_Negative(void){
1112   1              
1113   1      /*      srFlagScale.bFlagNeg = 1;
1114   1              srFlagScale.bOverLoad = 0;
1115   1              
1116   1              //En caso de un peso negativo verifica que no sea menor al peso tarado
1117   1              if((srFlagScale.bTara == 1) && ((-1)*stScaleParam.fWeightScale <= fCuentasToPeso(stScaleParam.fValueTara)
             -)){                
1118   1                      LCD_GLASS_Float(stScaleParam.fWeightScale, (int)stScaleParam.cWeightDecimal, LCD_PESO);
1119   1              }else{
1120   1                      LCD_GLASS_String("-----", LCD_PESO);
1121   1              }
1122   1              
1123   1              if(srFlagScale.bFlagFijarPRecio){
1124   1                      LCD_GLASS_String("------", LCD_TOTAL);
1125   1              }else{
1126   1                      stScaleParam.fPrice_Unit = 0;
1127   1                      stScaleParam.cNumberDecimalPrice = 0;
1128   1                      stScaleParam.fTotal_Venta = 0;
1129   1                      LCD_GLASS_String("     0", LCD_TOTAL);
1130   1              }
1131   1                      
1132   1              if(stScaleParam.cPuntoDecimalPrecio < 3){
1133   1                      LCD_GLASS_Float(stScaleParam.fPrice_Unit, stScaleParam.cPuntoDecimalPrecio, LCD_PRECIO);
1134   1              }else{
1135   1                      LCD_GLASS_Float(stScaleParam.fPrice_Unit, stScaleParam.cNumberDecimalPrice, LCD_PRECIO);
1136   1              }
1137   1              
1138   1              // Elimina el indicador de cero al presentar peso negativo 
1139   1              LCD_GLASS_Symbols(SYMBOL_ZERO, 0);      */              
1140   1      }
1141          
1142          /**
1143            ******************************************************************************
1144            * Objetivo: Calcular el peso.
1145            * Parametros entrada:
1146                  * Parametros Salida:
1147            * Prerequisitos: 
1148            ***
1149                  */
1150          
1151          void vCalculate_Weight (void){
1152   1      /***************
1153   1      Se toman 3 lecturas para garantizar el peso al realizar las sumas c/precio fijo, 
1154   1      si no hay precio fijo realiza solo una lectura de forma natural.
1155   1      ******************/     
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 20  

1156   1              char xdata i = 0, cCountPrecioFijo = 0;
1157   1      
1158   1              if(srFlagScale.bFlagFijarPRecio){       
1159   2                      cCountPrecioFijo = 3;                                           
1160   2              }
1161   1              else{
1162   2                      cCountPrecioFijo = 1;                   
1163   2              }
1164   1      
1165   1              for(i=0; i < cCountPrecioFijo; i++){
1166   2                      fWeightScale = fRead_Adc(1);                                    // Solicita el peso actual 
1167   2              }
1168   1              
1169   1              if(srFlagScale.bErrorResponseAdc == 1 || srFlagScale.bErrorReadAdc == 1){
1170   2                      LCD_GLASS_String(" -E- ", LCD_PESO);
1171   2                      return;
1172   2              }
1173   1              
1174   1              // Si esta la funcion ZeroTracking la ejecuta
1175   1              if(stScaleParam.cZeroTracking == 1 && srFlagScale.bTara == 0){
1176   2                      vGetZeroTracking(fWeightScale);
1177   2              }
1178   1              
1179   1              stScaleParam.fWeightScaleCount = fWeightScale;
1180   1              
1181   1              fWeightLight = fWeightScale;
1182   1              
1183   1              // Calcula peso bruto (numero de cuentas ADC del peso)
1184   1              fWeightScale -= stScaleParam.fPointZero;        
1185   1              stScaleParam.fWeightScaleTara = fWeightScale;
1186   1                      
1187   1              if(srFlagScale.bShowCountADC == 1){
1188   2                      fWeightScale = fCuentasToPeso(stScaleParam.fWeightScaleCount);
1189   2              }else{
1190   2                              // Verifica si esta la opcion de tara activada para mostrar indicador NET 
1191   2                      if(srFlagScale.bTara == 1){
1192   3                              fWeightLight = fWeightScale; 
1193   3                              fWeightScale -= stScaleParam.fValueTara;                        
1194   3                              if(srFlagScale.bOverLoad ==0){
1195   4                                      LCD_GLASS_Symbols(SYMBOL_NET, 1);
1196   4                              }
1197   3                      }               
1198   2                      fWeightScale = fCuentasToPeso(fWeightScale);            
1199   2              }
1200   1              
1201   1              if(fWeightScale < 0 && srFlagScale.bShowCountADC == 0){
1202   2                      srFlagScale.bFlagWeightNeg = 1;
1203   2              }else if(fWeightScale == 0){
1204   2                      srFlagScale.bFlagWeightNeg = 0;
1205   2              }
1206   1              
1207   1              stScaleParam.fWeightScale = fWeightScale;
1208   1      }
1209          
1210          /**
1211            ******************************************************************************
1212            * Objetivo: Redondea numero flotante.
1213            * Parametros entrada: Ninguno
1214                  * Parametros Salida: Ninguno
1215            ******************************************************************************
1216            */
1217          float fCuentasToPeso(float fCountADC){
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 21  

1218   1              
1219   1              float xdata fAuxFactorC = 0;
1220   1              float xdata fPesoFinal = 0; 
1221   1              float xdata fPesoAux = 0;
1222   1              long xdata iAuxPeso = 0;
1223   1              float xdata arfFactorMult = 0;
1224   1              char xdata cFlagNeg = 0;
1225   1              
1226   1              if(fCountADC < 0){
1227   2                      cFlagNeg = 1;
1228   2                      fCountADC *= (-1);
1229   2              }
1230   1              
1231   1              if(stScaleParam.cMultirango == 0){
1232   2                      arfFactorMult = (float)(stScaleParam.iDivisionMinima)/pow(10,(int)stScaleParam.cWeightDecimal);
1233   2                      fPesoAux = fCountADC/stScaleParam.fFactorCalibrate;     
1234   2              }else{
1235   2                      if (fCountADC <= stScaleParam.fCapacityCali*0.10){
1236   3                              fAuxFactorC = 0;
1237   3                              fAuxFactorC = (float)(stScaleParam.iDivisionMenorMenor)/(float)(stScaleParam.iDivisionMinima);
1238   3                              arfFactorMult = (float)(stScaleParam.iDivisionMenorMenor)/pow(10,(int)stScaleParam.cWeightDecimal);
1239   3                              fPesoAux = fCountADC/(stScaleParam.fFactorCalibrate*fAuxFactorC);                       
1240   3                      }               
1241   2                      else if (fCountADC <= stScaleParam.fCapacityCali*0.20){
1242   3                              fAuxFactorC = (float)(stScaleParam.iDivisionMenor)/(float)(stScaleParam.iDivisionMinima);
1243   3                              arfFactorMult = (float)(stScaleParam.iDivisionMenor)/pow(10,(int)stScaleParam.cWeightDecimal);
1244   3                              fPesoAux = fCountADC/(stScaleParam.fFactorCalibrate*fAuxFactorC);
1245   3                      }       
1246   2                      else{
1247   3                              arfFactorMult = (float)(stScaleParam.iDivisionMinima)/pow(10,(int)stScaleParam.cWeightDecimal);
1248   3                              fPesoAux = fCountADC/stScaleParam.fFactorCalibrate;
1249   3                      }
1250   2              }
1251   1              
1252   1              iAuxPeso = (long)fPesoAux;      
1253   1              
1254   1              fPesoAux -= (float)iAuxPeso;
1255   1              iAuxPeso += (long)(fPesoAux*2);
1256   1              fPesoFinal = (float)iAuxPeso*arfFactorMult;
1257   1              
1258   1              if(cFlagNeg){
1259   2                      fPesoFinal *= (-1);
1260   2              }
1261   1              
1262   1              return fPesoFinal;
1263   1      }
1264          
1265          /**
1266            ******************************************************************************
1267            * Objective: To Reduce the power consumption of the load cell.
1268            ******************************************************************************
1269                  */
1270          float fSleep_Run(void){
1271   1      float xdata fValueReturn = 0;   
1272   1      /*      float fWeightScale = 0;
1273   1              
1274   1              float fLimite = 0;
1275   1              int i = 0 ;     
1276   1              unsigned char cFlag_Continue = 1;       //Flag para 
1277   1              
1278   1              //Variable para rotar el mensaje
1279   1              unsigned char strMsgSaveBatt[16];
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 22  

1280   1              unsigned char strSave[6] = {0,0,0,0,0,0};
1281   1              unsigned char strBatt[7] = {0,0,0,0,0,0,0};
1282   1              unsigned char cDataTemp = 0;
1283   1              unsigned char cDataTemp1 = 0;
1284   1              unsigned char bStatus_Battery = 0;
1285   1      
1286   1              
1287   1              strcpy(strMsgSaveBatt, "---------- ");
1288   1              
1289   1              fLimite = fCuentasToPeso(stScaleParam.fFactorCalibrate);
1290   1              
1291   1              Time_Sleep;     //Reinicia el contador para realizar lectura del ADC
1292   1              
1293   1              for(i=0; i<11; i++){
1294   1                      if(i<5){
1295   1                              strSave[i] = strMsgSaveBatt[i];
1296   1                      }else if(i<11){
1297   1                              strBatt[i-5] = strMsgSaveBatt[i];
1298   1                      }
1299   1              }
1300   1              
1301   1              OffBackLight;//GPIO_ResetBits(GPIOA, BACK_LIGHT);       //Off BackLight
1302   1                                      
1303   1              LCD_GLASS_Symbols(SYMBOL_ALL, 0);
1304   1              LCD_GLASS_String("-----", LCD_PRECIO);
1305   1              LCD_GLASS_String("------", LCD_TOTAL);
1306   1              LCD_GLASS_Float(0, 0, LCD_PESO);
1307   1              
1308   1              while(cFlag_Continue){
1309   1                      //Verifica por que salio del Wait
1310   1                      if(srFlagScale.bScaleOn == 0){ //Si se oprimio la tecla On
1311   1                              cFlag_Continue = 0;
1312   1                      }else if(strTimer.iTimerB<TimerBend){ //Si ya pasaron 3 segundos
1313   1                              
1314   1                              fWeightScale = fRead_Adc(0);
1315   1                              
1316   1                              // Si esta la funcion ZeroTracking la ejecuta
1317   1                              if(stScaleParam.cZeroTracking == 1 && srFlagScale.bTara == 0){
1318   1                                      vGetZeroTracking(fWeightScale);
1319   1                              }
1320   1                              
1321   1                              stScaleParam.fWeightScaleCount = fWeightScale;
1322   1                              
1323   1                              // Calcula peso bruto (numero de cuentas ADC del peso)
1324   1                              fWeightScale -= stScaleParam.fPointZero;
1325   1                              fValueReturn = fWeightScale;
1326   1                              fWeightScale = fCuentasToPeso(fWeightScale);
1327   1                              
1328   1                              if(fWeightScale >= fLimite || fWeightScale < (-1)*(fLimite)){
1329   1                                      cFlag_Continue = 0;
1330   1                              }else if(vActionKey() != KEY_NULL){
1331   1                                      cFlag_Continue = 0;
1332   1                                      vBeep_Key();
1333   1                              }                               
1334   1                              
1335   1                              if(cFlag_Continue){                             
1336   1                                      
1337   1                                      //Verifica si ya esta conectado el elimnador para salir de bajo consumo
1338   1                                      bStatus_Battery = uGet_Status_Volt();
1339   1                                      
1340   1                                      if(bStatus_Battery != SOURCE_ADAPTER){ 
1341   1                                              vGestorBateria();
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 23  

1342   1                                      }else{
1343   1                                              cFlag_Continue = 0;
1344   1                                      }
1345   1                                      
1346   1                                      if(srFlagScale.bMsgBatteryLow == 0){
1347   1                                              //Muestra animacion de lineas 
1348   1                                              
1349   1                                              cDataTemp = strMsgSaveBatt[0];
1350   1                                              
1351   1                                              for(i=0; i<14; i++){
1352   1                                                      strMsgSaveBatt[i] = strMsgSaveBatt[i+1];
1353   1                                              }
1354   1                                              
1355   1                                              strMsgSaveBatt[10] = cDataTemp;
1356   1                                              
1357   1                                              for(i=0; i<11; i++){
1358   1                                                      if(i<5){
1359   1                                                              strSave[i] = strMsgSaveBatt[i];
1360   1                                                      }else if(i<11){
1361   1                                                              strBatt[i-5] = strMsgSaveBatt[i];
1362   1                                                      }
1363   1                                              }
1364   1                                              
1365   1                                              LCD_GLASS_String("    0", LCD_PESO);
1366   1                                              LCD_GLASS_String(strSave, LCD_PRECIO);
1367   1                                              LCD_GLASS_String(strBatt, LCD_TOTAL);
1368   1                                      }
1369   1                                      
1370   1                                      Time_Sleep;
1371   1                              }
1372   1                      }else if(vActionKey() != KEY_NULL){
1373   1                              cFlag_Continue = 0;
1374   1                              vBeep_Key();
1375   1                      }
1376   1                      
1377   1                      if(srFlagScale.bScaleOn == 0){
1378   1                              cFlag_Continue = 0;
1379   1                      }
1380   1                      
1381   1                      if(srFlagScale.cAuto_Off_Time == 1 && stScaleParam.cTimeAutooff == 1){
1382   1                              srFlagScale.bScaleOn = 0;
1383   1                              cFlag_Continue = 0;
1384   1                      }
1385   1              }       
1386   1              
1387   1              if(srFlagScale.bBacklight_On){
1388   1                      if(stScaleParam.cBacklight){OnBackLight;}
1389   1              }
1390   1              
1391   1      ///////CCC///////CCC    CLK_PeripheralClockConfig(CLK_Peripheral_ADC1, ENABLE);
1392   1              //Restart_Sleep_Time;
1393   1              //Auto_Off_On_15m;
1394   1              */
1395   1              return fValueReturn;
1396   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4621    ----
   CONSTANT SIZE    =     77    ----
   XDATA SIZE       =    139      66
   PDATA SIZE       =   ----    ----
C51 COMPILER V7.50   DVR_SCALE                                                             09/27/2022 18:31:38 PAGE 24  

   DATA SIZE        =   ----      19
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
