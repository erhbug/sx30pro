C51 COMPILER V7.50   MAIN                                                                  09/14/2022 19:11:56 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE customer\main.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\main.lst) OBJECT(ma
                    -in.obj)

line level    source

   1          //#pragma code symbols debug oe
   2          //#define EXTERN
   3          #include <REG52.H>
   4          //#include <math.h>
   5          #include "./_solidic/head_file_version.h"
   6          #include "./_display/dvr_lcd_SDI1621.h"
*** WARNING C245 IN LINE 40 OF C:\KEIL\C51\INC\STDIO.H: unknown #pragma, line ignored
*** WARNING C245 IN LINE 52 OF C:\KEIL\C51\INC\STRING.H: unknown #pragma, line ignored
   7          #include "./_weight/dvr_HX712.h"
   8          
   9          
  10          unsigned char Key;
  11          unsigned char lecturaADC[4]= {0};
  12          static unsigned char cont = 0;
  13          
  14          #define     BL_EN       P1 |= 0x20
  15          #define     BL_DIS      P1 &= 0xDF
  16          
  17          #define     BEEPER_EN   P1 |= 0x10
  18          #define     BEEPER_DIS  P1 &= 0xEF
  19          
  20          unsigned int convertidorADC(void);
  21          
  22          void init_pwm(void){
  23   1          PWMF_H  = 0x00;
  24   1              PWMF_L  = 0x20;
  25   1              PWM0    = 05;
  26   1              PWM1    = 03;
  27   1              PWMCON  = 0x04; //PWM0-P1.4(LCD_LAMP)????(?PWM0=0xff?,?????)
  28   1      }
  29          
  30          
  31          void TestEEPROM(void)
  32          {
  33   1              unsigned int addr=ADDRESS_PLU+4;
  34   1              float val;
  35   1              unsigned char txt[10]={0};
  36   1              float i=0.00;
  37   1      
  38   1              unsigned int x=0;
  39   1       
  40   1              NRM_securty_a = 0xaa;
  41   1              NRM_securty_b = 0x55;
  42   1      while(1){
  43   2              flash_write_float32(addr,i);
  44   2      
  45   2              val = flash_read_float32(addr);
  46   2              sprintf(txt,"%f",val);  LCD_GLASS_String(txt,LCD_PESO); 
  47   2              i+=1.00;
  48   2              }
  49   1      /*      while(1){       
  50   1              for(x=0;x<40;x+=4){
  51   1      
  52   1              flash_write_float32(addr+x,i);
C51 COMPILER V7.50   MAIN                                                                  09/14/2022 19:11:56 PAGE 2   

  53   1      
  54   1              val = flash_read_float32(addr+x-4);
  55   1              sprintf(txt,"%f",val);  LCD_GLASS_String(txt,LCD_PESO); 
  56   1      
  57   1              val = flash_read_float32(addr+x);
  58   1              sprintf(txt,"%f",val);  LCD_GLASS_String(txt,LCD_TOTAL);        
  59   1      
  60   1              val = flash_read_float32(addr+x+4);
  61   1              sprintf(txt,"%f",val);  LCD_GLASS_String(txt,LCD_PRECIO); 
  62   1      
  63   1              i++;
  64   1              delay_ms(1000);
  65   1              }
  66   1      }*/
  67   1      
  68   1      NRM_securty_a = 0x00;
  69   1              NRM_securty_b = 0x00;
  70   1      }
  71          
  72          void main(void)
  73          {char txt[5]={0};
  74   1       float peso=0, voltaje=0;
  75   1              //int a = 0, b = 0;
  76   1          P0M0 = 0xF0; //0b11111111;
  77   1          P0M1 = 0x00; //0b00000000;    
  78   1          P1M0 = 0xBF; //0b10111111;
  79   1          P1M1 = 0x00; //0b00000000;        
  80   1          P2M0 = 0xEE; //0b11101110;
  81   1          P2M1 = 0x00; //0b00000000;
  82   1              //Config lectura adc
  83   1              P0M0 &= ~(1<<5);
  84   1              P0M1 |= (1<<5);
  85   1              //Configuracion salida BL
  86   1          P1M0 |= (1<<5);
  87   1          P1M1 &= ~(1<<5);
  88   1              //Configuracion salida BL
  89   1          P0M0 |= (1<<1);
  90   1          P0M1 &= ~(1<<1);
  91   1      /*bit KEY_K0 = P0^2;    
  92   1      sbit KEY_K1 = P2^4;     
  93   1      sbit KEY_K2 = P2^0;     
  94   1      sbit KEY_K3 = P1^6;             */
  95   1      
  96   1      /*      P1M0 = 0xff;
  97   1              P1M1 = 0x00;
  98   1              P2M0 = 0xff;
  99   1              P2M1 = 0x00;*/
 100   1      
 101   1          P0 = 0x0C;//P0 = 0x04;
 102   1          P1 = 0x40;
 103   1          P2 = 0x11;
 104   1              //Salida en 1  para lectura adc
 105   1              P0|= (1<<5);
 106   1              
 107   1              //Interrupcion timer0
 108   1              IE = 0x82;
 109   1              IP = 0x02;
 110   1              
 111   1              //timer0
 112   1              TMOD = 0x00;
 113   1              TL0 = 0x00;
 114   1              TH0 = 0x7F;
C51 COMPILER V7.50   MAIN                                                                  09/14/2022 19:11:56 PAGE 3   

 115   1              CKCON = 0x04;
 116   1      
 117   1      /*      P2 = 0x00;
 118   1              P1 = 0x00;*/
 119   1      
 120   1              iLCD_GLASS_Init();
 121   1                              delay_ms(500);
 122   1              LCD_GLASS_String("TORR",LCD_PESO);
 123   1                      delay_ms(500);
 124   1              LCD_GLASS_String("EY",LCD_PRECIO);
 125   1                              delay_ms(500);    
 126   1       
 127   1              init_pwm();
 128   1              BL_DIS;
 129   1              BEEPER_EN;
 130   1              
 131   1      
 132   1      /*      while(1)
 133   1              {
 134   1              KEY_D0=1;
 135   1      KEY_D1=1;
 136   1      KEY_D2=1;
 137   1      KEY_D3=1;
 138   1      KEY_D4=1;
 139   1      delay_ms(100);
 140   1      
 141   1      KEY_D0=0;
 142   1      KEY_D1=0;
 143   1      KEY_D2=0;
 144   1      KEY_D3=0;
 145   1      KEY_D4=0;
 146   1      delay_ms(100);
 147   1      
 148   1              }*/
 149   1       TCON |= (1<<4);
 150   1       iLCD_GLASS_Clear();
 151   1      
 152   1       TestEEPROM();
 153   1       while(1){   
 154   2       /*key_scan();
 155   2              sprintf(txt,"%d  ",(int)(Key));
 156   2              LCD_GLASS_String(txt,LCD_TOTAL)*/
 157   2      
 158   2              //sprintf(txt,"%d  ",(int)(KeyState));
 159   2              //LCD_GLASS_String(txt,LCD_PRECIO);
 160   2      
 161   2              
 162   2              delay_ms(50);
 163   2      
 164   2              peso=fRead_Adc(0);
 165   2              sprintf(txt,"%f   ",peso);  LCD_GLASS_String(txt,LCD_PESO); 
 166   2      
 167   2              P0|= (1<<5);
 168   2              voltaje=convertidorADC()*(3.3/255);
 169   2      //      LCD_GLASS_Float(peso, 2,  LCD_TOTAL);
 170   2      //      LCD_GLASS_Float(voltaje, 2, LCD_PESO);
 171   2      
 172   2      }
 173   1      
 174   1      }
 175          
 176          unsigned int convertidorADC(){
C51 COMPILER V7.50   MAIN                                                                  09/14/2022 19:11:56 PAGE 4   

 177   1      
 178   1      unsigned int v=0;
 179   1      SARCON = 0x09;
 180   1              if(!(SARCON & 0x04))
 181   1              {
 182   2                      SARCON |= 0x04;
 183   2                      while(SARCON & 0x04)
 184   2                      {
 185   3                      }
 186   2              }
 187   1      v=SARDATA;
 188   1      SARCON &= 0xf7;
 189   1      return v;
 190   1      
 191   1      }
 192          
 193          static void timer0(void) interrupt 1
 194          {               
 195   1              //static unsigned char cont = 0;
 196   1              //IE = 0;        // 禁止中断
 197   1              //P1 &= ~(1<<5);
 198   1              /*if(cont==40){
 199   1                      P1 |= (1<<5);
 200   1                      cont = 0;
 201   1                      }*/
 202   1              P0 ^= (1<<1);//P1 ^= (1<<5);
 203   1              TL0 = 0xCF;
 204   1              TH0 = 0xAF;
 205   1              /*if(cont){
 206   1                      cont = 0;
 207   1                      P1 &= ~(1<<5);
 208   1              }else{
 209   1                      cont = 1;
 210   1                      P1 |= (1<<5);
 211   1                      }*/
 212   1              //TCON |= (1<<4);
 213   1              //IE = 0x02;  // 打开中断
 214   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    516    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =      6      35
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
