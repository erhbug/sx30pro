C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/23/2022 09:42:37 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE DATA_NVM_5219_VC_DEC09_13
OBJECT MODULE PLACED IN data_nvm_5219_Vc_Dec09_13.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE _data_nvm\data_nvm_5219_Vc_Dec09_13.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\data_nvm_5219_Vc_Dec09_13.lst) OBJECT(data_nvm_5219_Vc_Dec09_13.obj)

line level    source

   1          //*************************************************************************//
   2          //* Name                                :   data_nvm_825.c
   3          //* Vision                              :       V-Jun20_13
   4          //* Project                             :   
   5          //* Function                    :   Solidic 电子称 非易失性数据 操作
   6          //* $Author                             :   superc
   7          //*
   8          //* Copyright 2012 by solidic
   9          //*
  10          //* Recode:
  11          //*                                             1: 2013-06-20  First Creat By Superc
  12          //*
  13          //*
  14          //*
  15          //*************************************************************************//
  16          #include <REG52.H>
  17          #include <absacc.h>
  18          #include "./_solidic/solidic_Vc_Jan10_13.h"                                                     
  19          #include "./_solidic/SDI5219_Vc_Sep02_15.h"     
  20          #include "./_data_nvm/data_nvm_5219_Vc_Dec09_13.h"      
  21          #include "./_scale/dvr_def.h"
  22          
  23          unsigned char NRM_securty_a;                                            // EEPROM 安全码A
  24          unsigned char NRM_securty_b;    
  25          
  26          void ClearThisButAll(unsigned int Address, unsigned int IntCount);
  27          
  28          volatile void nop(void){
  29   1       unsigned int x=1;
  30   1       x<<=1;
  31   1      }
  32          
  33          unsigned char flash_read_u8(unsigned int addr)
  34          {
  35   1              unsigned char val;
  36   1              val = CBYTE[addr];      
  37   1              return(val);
  38   1      }
  39          
  40          unsigned int  flash_read_u16(unsigned int addr)
  41          {
  42   1              unsigned int val;
  43   1                      unsigned char *ptr;
  44   1                      unsigned char i;
  45   1              
  46   1                      ptr=(unsigned char *)&val;
  47   1                      for(i=0;i<2;i++)
  48   1                      {  
  49   2                        *(ptr++) =flash_read_u8(addr++);
  50   2                      }
  51   1                      return(val);
  52   1      }
  53          
  54          unsigned long  flash_read_u32(unsigned int addr)
C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/23/2022 09:42:37 PAGE 2   

  55          {
  56   1          unsigned long val;
  57   1                      unsigned char *ptr;
  58   1                      unsigned char i;
  59   1              
  60   1                      ptr=(unsigned char *)&val;
  61   1                      for(i=0;i<4;i++)
  62   1                      {  
  63   2                        *(ptr++) =flash_read_u8(addr++);
  64   2                      }
  65   1                      return(val);
  66   1      }
  67          
  68          float flash_read_float32(unsigned int addr)
  69                  {
  70   1                  float val;
  71   1                      unsigned char *ptr;
  72   1                      unsigned char i;
  73   1              
  74   1                      ptr=(unsigned char *)&val;
  75   1                      for(i=0;i<4;i++)
  76   1                      {  
  77   2                        *(ptr++) =flash_read_u8(addr++);
  78   2                      }
  79   1                      return(val);
  80   1              }
  81          
  82          
  83          void nvm_data_write_byte(unsigned int addr,unsigned char in_data)
  84          {
  85   1              union INTpattern flash_addr;
  86   1              bit ea_save;
  87   1              unsigned char i=0;
  88   1      
  89   1          IWDG_KEY_REFRESH;
  90   1              flash_addr.i = addr;
  91   1              ea_save  =  EA;            // Save EA
  92   1              EA = 0;
  93   1              //-- 准备地址和数据 --
  94   1              FLASH_ADDRH = flash_addr.b[0]; // point to the address you want to erase 
  95   1              FLASH_ADDRL = flash_addr.b[1]; 
  96   1              FLASH_DATA = in_data;   
  97   1      
  98   1              //-- 状态清除 --
  99   1              FLASH_ENA = 0x00;
 100   1              FLASH_ENB = 0x00;
 101   1              FLASH_ENC = 0x00;
 102   1              //-- 通过安全检验后才能启动 Flash 操作 --
 103   1              if((NRM_securty_a == 0xaa)&&(NRM_securty_b == 0x55))
 104   1                      FLASH_CON = 0x03;       //状态清除，执行一次FLASH_CON，将安全状态复位
 105   1                      nop();  //延时
 106   1              //-- 写安全码开启Flash操作许可 --               
 107   1              FLASH_ENA = 0x05;
 108   1              FLASH_ENB = 0x0a;
 109   1              FLASH_ENC = 0x09;
 110   1              //-- 通过安全检验后才能启动 Flash 操作 --
 111   1              if((NRM_securty_a == 0xaa)&&(NRM_securty_b == 0x55))
 112   1                      FLASH_CON = 0x03;
 113   1              //-- 清除安全码 --
 114   1              FLASH_ENA = 0x00;
 115   1              FLASH_ENB = 0x00;
 116   1              FLASH_ENC = 0x00;
C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/23/2022 09:42:37 PAGE 3   

 117   1              EA = ea_save;
 118   1      }
 119          
 120          void flash_write_u8(unsigned int addr,unsigned char in_data)
 121          {
 122   1        /****************************/
 123   1              if( flash_read_u8(addr)!=0xFF)
 124   1                ClearThisButAll(addr,1);              
 125   1        /****************************/
 126   1                nvm_data_write_byte(addr,in_data);    
 127   1      }
 128          
 129          void flash_write_u16(unsigned int addr,unsigned int in_data)
 130          {
 131   1              unsigned char *ptr;
 132   1              unsigned char i;
 133   1      
 134   1              /****************************/
 135   1              unsigned int aux;
 136   1              aux=flash_read_u16(addr);
 137   1          ptr=(unsigned char *)&aux;
 138   1              if( *(ptr++)!=0xFF || *(ptr++)!=0xFF)
 139   1                ClearThisButAll(addr,2);              
 140   1              /****************************/
 141   1      
 142   1              ptr=(unsigned char *)&in_data;
 143   1              for(i=0;i<2;i++)
 144   1              {
 145   2                nvm_data_write_byte(addr++,*(ptr++));
 146   2              }       
 147   1      }
 148          
 149          void flash_write_u32(unsigned int addr,unsigned long in_data)
 150          {
 151   1              unsigned char *ptr;
 152   1              unsigned char i;
 153   1      
 154   1              /****************************/
 155   1              unsigned long aux;
 156   1              aux=flash_read_u32(addr);
 157   1          ptr=(unsigned char *)&aux;
 158   1              if( *(ptr++)!=0xFF || *(ptr++)!=0xFF || *(ptr++)!=0xFF || *(ptr++)==0xFF )
 159   1                ClearThisButAll(addr,4);              
 160   1              /****************************/
 161   1      
 162   1              ptr=(unsigned char *)&in_data;
 163   1              for(i=0;i<4;i++)
 164   1              {
 165   2                nvm_data_write_byte(addr++,*(ptr++));
 166   2              }       
 167   1      }
 168          
 169          void flash_write_float32(unsigned int addr,float in_data)
 170          {
 171   1              unsigned char *ptr;
 172   1              unsigned char i;
 173   1      
 174   1              /****************************/
 175   1              float aux;
 176   1              aux=flash_read_float32(addr);
 177   1          ptr=(unsigned char *)&aux;
 178   1              if( *(ptr++)!=0xFF || *(ptr++)!=0xFF || *(ptr++)!=0xFF || *(ptr++)==0xFF )
C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/23/2022 09:42:37 PAGE 4   

 179   1                ClearThisButAll(addr,4);              
 180   1              /****************************/
 181   1      
 182   1              ptr=(unsigned char *)&in_data;
 183   1              for(i=0;i<4;i++)
 184   1              {
 185   2                nvm_data_write_byte(addr++,*(ptr++));
 186   2              }       
 187   1      }
 188          
 189          //EEPROM BLOCK(1k) 擦除
 190          //addr = （0 - 31）* 1024 ,擦除对应的Block地址
 191          //调用前需要:
 192          //NRM_securty_a,NRM_securty_b
 193          //flash操作关闭总中断，操作完后会开启总中断(注意)
 194          void e2rom_erase(unsigned int addr)
 195          {unsigned char i=0;
 196   1              union INTpattern flash_addr;
 197   1              bit ea_save;
 198   1              flash_addr.i = addr;
 199   1              ea_save  =  EA;            // Save EA
 200   1              EA = 0;
 201   1              FLASH_ADDRH = flash_addr.b[0]; // point to the address you want to erase 
 202   1              FLASH_ADDRL = flash_addr.b[1]; 
 203   1              //-- 状态清除 --
 204   1              FLASH_ENA = 0x00;
 205   1              FLASH_ENB = 0x00;
 206   1              FLASH_ENC = 0x00;
 207   1              //-- 通过安全检验后才能启动 Flash 操作 --
 208   1              if((NRM_securty_a == 0xaa)&&(NRM_securty_b == 0x55))
 209   1                      FLASH_CON = 0x03;       //状态清除，执行一次FLASH_CON，将安全状态复位
 210   1              nop();
 211   1              //-- 写安全码开启Flash操作许可 --
 212   1              FLASH_ENA = 0x05;
 213   1              FLASH_ENB = 0x0a;
 214   1              FLASH_ENC = 0x09;
 215   1              //-- 通过安全检验后才能启动 Flash 操作 --
 216   1              if((NRM_securty_a == 0xaa)&&(NRM_securty_b == 0x55))
 217   1                      FLASH_CON = 0x0c;
 218   1              //-- 清除安全码 --
 219   1              FLASH_ENA = 0x00;
 220   1              FLASH_ENB = 0x00;
 221   1              FLASH_ENC = 0x00;
 222   1              EA = ea_save;   
 223   1      }
 224          
 225          void ClearThisButAll(unsigned int Address, unsigned int IntCount){
 226   1              unsigned char Aux=0;    
 227   1              unsigned int i=0;
 228   1              unsigned int Page;      
 229   1              unsigned int SizePage=0x400;
 230   1              
 231   1              /*Determinar en que pagina se encuentra*/
 232   1              Page=Address/SizePage;
 233   1              Page*=SizePage;
 234   1              /**************************************/
 235   1      
 236   1              /*Verificar que la pagina auxiliar este limpia, de lo contrario borrarla*/
 237   1              for(i=0;i<10;i++){              
 238   2                      if(flash_read_u8(ADDRESS_AUX_PAGE+i) != 0xFF)
 239   2                              e2rom_erase(ADDRESS_AUX_PAGE);//vSend_String_Usart(&huart1,"Pag Auxiliar Limpia\r\n");          
 240   2              }       
C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/23/2022 09:42:37 PAGE 5   

 241   1              /***********************************************************************/
 242   1              
 243   1              /*Copiar de la pagina origen a la auxiliar*/
 244   1              for(i=0;i<SizePage;i++){
 245   2                      if(i+Page==Address)/*Copiar SizeToCopy enteros excepto IntCount enteros a partir de Address */
 246   2                              i+=IntCount;    
 247   2                      nvm_data_write_byte(ADDRESS_AUX_PAGE + i, flash_read_u8(Page + i));             
 248   2        }
 249   1              /****************************************/      
 250   1              
 251   1              /*Borrar pagina de origen*/
 252   1              e2rom_erase(Page);      
 253   1              /*************************/
 254   1      
 255   1              /*Regresar datos a pagina origen*/
 256   1              for(i=0;i<SizePage;i++){
 257   2                      nvm_data_write_byte(Page + i, flash_read_u8(ADDRESS_AUX_PAGE + i));             
 258   2              }
 259   1              /********************************/
 260   1      
 261   1              /*Borrar pagina auxiliar*/
 262   1              e2rom_erase(ADDRESS_AUX_PAGE);  
 263   1              /************************/
 264   1      }
 265          
 266          
 267          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1262    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      78
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
