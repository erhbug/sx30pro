C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/15/2022 11:23:28 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE DATA_NVM_5219_VC_DEC09_13
OBJECT MODULE PLACED IN data_nvm_5219_Vc_Dec09_13.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE _data_nvm\data_nvm_5219_Vc_Dec09_13.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\data_nvm_5219_Vc_Dec09_13.lst) OBJECT(data_nvm_5219_Vc_Dec09_13.obj)

line level    source

   1          //*************************************************************************//
   2          //* Name                                :   data_nvm_825.c
   3          //* Vision                              :       V-Jun20_13
   4          //* Project                             :   
   5          //* Function                    :   Solidic 电子称 非易失性数据 操作
   6          //* $Author                             :   superc
   7          //*
   8          //* Copyright 2012 by solidic
   9          //*
  10          //* Recode:
  11          //*                                             1: 2013-06-20  First Creat By Superc
  12          //*
  13          //*
  14          //*
  15          //*************************************************************************//
  16          #include <REG52.H>
  17          #include <absacc.h>
  18          #include <math.h>
  19          
  20          //***************************************************************************
  21          // -- 全部头文件 集中管理 ---- ，版本修改文件名会变动 ---  必须修改 这个文件
  22          //***************************************************************************
  23          #include "./_solidic/head_file_version.h"
  24          unsigned char NRM_securty_a;                                            // EEPROM 安全码A
  25          unsigned char NRM_securty_b;    
  26          
  27          void ClearThisButAll(unsigned int Address, unsigned int IntCount);
  28          
  29          volatile void nop(void){
  30   1       unsigned int x=1;
  31   1       x<<=1;
  32   1      }
  33          
  34          
  35          //读取EEPROM中的一个字节；
  36          unsigned char flash_read_u8(unsigned int addr)
  37          {
  38   1              unsigned char val;
  39   1              val = CBYTE[addr];      
  40   1              return(val);
  41   1      }
  42          
  43          unsigned int  flash_read_u16(unsigned int addr)
  44          {
  45   1              unsigned int val;
  46   1                      unsigned char *ptr;
  47   1                      unsigned char i;
  48   1              
  49   1                      ptr=(unsigned char *)&val;
  50   1                      for(i=0;i<2;i++)
  51   1                      {  
  52   2                        *(ptr++) =flash_read_u8(addr++);
  53   2                      }
  54   1                      return(val);
C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/15/2022 11:23:28 PAGE 2   

  55   1      }
  56          
  57          unsigned long  flash_read_u32(unsigned int addr)
  58          {
  59   1          unsigned long val;
  60   1                      unsigned char *ptr;
  61   1                      unsigned char i;
  62   1              
  63   1                      ptr=(unsigned char *)&val;
  64   1                      for(i=0;i<4;i++)
  65   1                      {  
  66   2                        *(ptr++) =flash_read_u8(addr++);
  67   2                      }
  68   1                      return(val);
  69   1      }
  70          
  71          float flash_read_float32(unsigned int addr)
  72                  {
  73   1                  float val;
  74   1                      unsigned char *ptr;
  75   1                      unsigned char i;
  76   1              
  77   1                      ptr=(unsigned char *)&val;
  78   1                      for(i=0;i<4;i++)
  79   1                      {  
  80   2                        *(ptr++) =flash_read_u8(addr++);
  81   2                      }
  82   1                      return(val);
  83   1              }
  84          
  85          
  86          void nvm_data_write_byte(unsigned int addr,unsigned char in_data)
  87          {
  88   1              union INTpattern flash_addr;
  89   1              bit ea_save;
  90   1              unsigned char i=0;
  91   1      
  92   1              flash_addr.i = addr;
  93   1              ea_save  =  EA;            // Save EA
  94   1              EA = 0;
  95   1              //-- 准备地址和数据 --
  96   1              FLASH_ADDRH = flash_addr.b[0]; // point to the address you want to erase 
  97   1              FLASH_ADDRL = flash_addr.b[1]; 
  98   1              FLASH_DATA = in_data;
  99   1      
 100   1              
 101   1      
 102   1              //-- 状态清除 --
 103   1              FLASH_ENA = 0x00;
 104   1              FLASH_ENB = 0x00;
 105   1              FLASH_ENC = 0x00;
 106   1              //-- 通过安全检验后才能启动 Flash 操作 --
 107   1              if((NRM_securty_a == 0xaa)&&(NRM_securty_b == 0x55))
 108   1                      FLASH_CON = 0x03;       //状态清除，执行一次FLASH_CON，将安全状态复位
 109   1                      nop();  //延时
 110   1              //-- 写安全码开启Flash操作许可 --               
 111   1              FLASH_ENA = 0x05;
 112   1              FLASH_ENB = 0x0a;
 113   1              FLASH_ENC = 0x09;
 114   1              //-- 通过安全检验后才能启动 Flash 操作 --
 115   1              if((NRM_securty_a == 0xaa)&&(NRM_securty_b == 0x55))
 116   1                      FLASH_CON = 0x03;
C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/15/2022 11:23:28 PAGE 3   

 117   1              //-- 清除安全码 --
 118   1              FLASH_ENA = 0x00;
 119   1              FLASH_ENB = 0x00;
 120   1              FLASH_ENC = 0x00;
 121   1              EA = ea_save;
 122   1      }
 123          
 124          void flash_write_u8(unsigned int addr,unsigned char in_data)
 125          {
 126   1        /****************************/
 127   1              if( flash_read_u8(addr)!=0xFF)
 128   1                ClearThisButAll(addr,1);              
 129   1        /****************************/
 130   1                nvm_data_write_byte(addr,in_data);    
 131   1      }
 132          
 133          void flash_write_u16(unsigned int addr,unsigned int in_data)
 134          {
 135   1              unsigned char *ptr;
 136   1              unsigned char i;
 137   1      
 138   1              /****************************/
 139   1              unsigned int aux;
 140   1              aux=flash_read_u16(addr);
 141   1          ptr=(unsigned char *)&aux;
 142   1              if( *(ptr++)!=0xFF || *(ptr++)!=0xFF)
 143   1                ClearThisButAll(addr,2);              
 144   1              /****************************/
 145   1      
 146   1              ptr=(unsigned char *)&in_data;
 147   1              for(i=0;i<2;i++)
 148   1              {
 149   2                nvm_data_write_byte(addr++,*(ptr++));
 150   2              }       
 151   1      }
 152          
 153          void flash_write_u32(unsigned int addr,unsigned long in_data)
 154          {
 155   1              unsigned char *ptr;
 156   1              unsigned char i;
 157   1      
 158   1              /****************************/
 159   1              unsigned long aux;
 160   1              aux=flash_read_u32(addr);
 161   1          ptr=(unsigned char *)&aux;
 162   1              if( *(ptr++)!=0xFF || *(ptr++)!=0xFF || *(ptr++)!=0xFF || *(ptr++)==0xFF )
 163   1                ClearThisButAll(addr,4);              
 164   1              /****************************/
 165   1      
 166   1              ptr=(unsigned char *)&in_data;
 167   1              for(i=0;i<4;i++)
 168   1              {
 169   2                nvm_data_write_byte(addr++,*(ptr++));
 170   2              }       
 171   1      }
 172          
 173          void flash_write_float32(unsigned int addr,float in_data)
 174          {
 175   1              unsigned char *ptr;
 176   1              unsigned char i;
 177   1      
 178   1              /****************************/
C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/15/2022 11:23:28 PAGE 4   

 179   1              float aux;
 180   1              aux=flash_read_float32(addr);
 181   1          ptr=(unsigned char *)&aux;
 182   1              if( *(ptr++)!=0xFF || *(ptr++)!=0xFF || *(ptr++)!=0xFF || *(ptr++)==0xFF )
 183   1                ClearThisButAll(addr,4);              
 184   1              /****************************/
 185   1      
 186   1              ptr=(unsigned char *)&in_data;
 187   1              for(i=0;i<4;i++)
 188   1              {
 189   2                nvm_data_write_byte(addr++,*(ptr++));
 190   2              }       
 191   1      }
 192          
 193          //EEPROM BLOCK(1k) 擦除
 194          //addr = （0 - 31）* 1024 ,擦除对应的Block地址
 195          //调用前需要:
 196          //NRM_securty_a,NRM_securty_b
 197          //flash操作关闭总中断，操作完后会开启总中断(注意)
 198          void e2rom_erase(unsigned int addr)
 199          {unsigned char i=0;
 200   1              union INTpattern flash_addr;
 201   1              bit ea_save;
 202   1              flash_addr.i = addr;
 203   1              ea_save  =  EA;            // Save EA
 204   1              EA = 0;
 205   1              FLASH_ADDRH = flash_addr.b[0]; // point to the address you want to erase 
 206   1              FLASH_ADDRL = flash_addr.b[1]; 
 207   1              //-- 状态清除 --
 208   1              FLASH_ENA = 0x00;
 209   1              FLASH_ENB = 0x00;
 210   1              FLASH_ENC = 0x00;
 211   1              //-- 通过安全检验后才能启动 Flash 操作 --
 212   1              if((NRM_securty_a == 0xaa)&&(NRM_securty_b == 0x55))
 213   1                      FLASH_CON = 0x03;       //状态清除，执行一次FLASH_CON，将安全状态复位
 214   1              nop();
 215   1              //-- 写安全码开启Flash操作许可 --
 216   1              FLASH_ENA = 0x05;
 217   1              FLASH_ENB = 0x0a;
 218   1              FLASH_ENC = 0x09;
 219   1              //-- 通过安全检验后才能启动 Flash 操作 --
 220   1              if((NRM_securty_a == 0xaa)&&(NRM_securty_b == 0x55))
 221   1                      FLASH_CON = 0x0c;
 222   1              //-- 清除安全码 --
 223   1              FLASH_ENA = 0x00;
 224   1              FLASH_ENB = 0x00;
 225   1              FLASH_ENC = 0x00;
 226   1              EA = ea_save;   
 227   1      }
 228          
 229          void ClearThisButAll(unsigned int Address, unsigned int IntCount){
 230   1              unsigned char Aux=0;    
 231   1              unsigned int i=0;
 232   1              unsigned int Page;      
 233   1              unsigned int SizePage=0x400;
 234   1              
 235   1              /*Determinar en que pagina se encuentra*/
 236   1              Page=Address/SizePage;
 237   1              Page*=SizePage;
 238   1              /**************************************/
 239   1      
 240   1              /*Verificar que la pagina auxiliar este limpia, de lo contrario borrarla*/
C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/15/2022 11:23:28 PAGE 5   

 241   1              for(i=0;i<10;i++){              
 242   2                      if(flash_read_u8(ADDRESS_AUX_PAGE+i) != 0xFF)
 243   2                              e2rom_erase(ADDRESS_AUX_PAGE);//vSend_String_Usart(&huart1,"Pag Auxiliar Limpia\r\n");          
 244   2              }       
 245   1              /***********************************************************************/
 246   1              
 247   1              /*Copiar de la pagina origen a la auxiliar*/
 248   1              for(i=0;i<SizePage;i++){
 249   2                      if(i+Page==Address)/*Copiar SizeToCopy enteros excepto IntCount enteros a partir de Address */
 250   2                              i+=IntCount;    
 251   2                      nvm_data_write_byte(ADDRESS_AUX_PAGE + i, flash_read_u8(Page + i));             
 252   2        }
 253   1              /****************************************/      
 254   1              
 255   1              /*Borrar pagina de origen*/
 256   1              e2rom_erase(Page);      
 257   1              /*************************/
 258   1      
 259   1              /*Regresar datos a pagina origen*/
 260   1              for(i=0;i<SizePage;i++){
 261   2                      nvm_data_write_byte(Page + i, flash_read_u8(ADDRESS_AUX_PAGE + i));             
 262   2              }
 263   1              /********************************/
 264   1      
 265   1              /*Borrar pagina auxiliar*/
 266   1              e2rom_erase(ADDRESS_AUX_PAGE);  
 267   1              /************************/
 268   1      }
 269          
 270          /*void TestEEPROM(void)
 271          {
 272                  unsigned int addr=ADDRESS_PLU;
 273                  float val;
 274                  unsigned char txt[10]={0};
 275                  float i=0.12;
 276          
 277                  unsigned int x=0;
 278           
 279                  NRM_securty_a = 0xaa;
 280                  NRM_securty_b = 0x55;
 281                  
 282                  flash_write_float32(addr,0.00);
 283                  flash_write_float32(addr+11,0.00);
 284          
 285                  while(1){       
 286                  for(x=1;x<11;x++){
 287                  flash_write_float32(addr+(x*4),i);
 288          
 289                  val = flash_read_float32(addr+(x*4)-4);
 290                  sprintf(txt,"%f",val);  LCD_GLASS_String(txt,LCD_PESO); 
 291          
 292                  val = flash_read_float32(addr+(x*4));
 293                  sprintf(txt,"%f",val);  LCD_GLASS_String(txt,LCD_TOTAL);        
 294          
 295                  val = flash_read_float32(addr+(x*4)+4);
 296                  sprintf(txt,"%f",val);  LCD_GLASS_String(txt,LCD_PRECIO); 
 297          
 298                  i++;
 299                  delay_ms(1000);
 300                  }
 301          }
 302          
C51 COMPILER V7.50   DATA_NVM_5219_VC_DEC09_13                                             09/15/2022 11:23:28 PAGE 6   

 303          NRM_securty_a = 0x00;
 304                  NRM_securty_b = 0x00;
 305          }*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1253    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      78
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
